// Copyright 2016 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.25.0
// 	protoc        v3.12.1
// source: safebrowsing.proto

package main

import (
	proto "github.com/golang/protobuf/proto"
	duration "github.com/golang/protobuf/ptypes/duration"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// This is a compile-time assertion that a sufficiently up-to-date version
// of the legacy proto package is being used.
const _ = proto.ProtoPackageIsVersion4

// Types of threats.
type ThreatType int32

const (
	// Unknown.
	ThreatType_THREAT_TYPE_UNSPECIFIED ThreatType = 0
	// Malware threat type.
	ThreatType_MALWARE ThreatType = 1
	// Social engineering threat type.
	ThreatType_SOCIAL_ENGINEERING ThreatType = 2
	// Unwanted software threat type.
	ThreatType_UNWANTED_SOFTWARE ThreatType = 3
	// Potentially harmful application threat type.
	ThreatType_POTENTIALLY_HARMFUL_APPLICATION ThreatType = 4
)

// Enum value maps for ThreatType.
var (
	ThreatType_name = map[int32]string{
		0: "THREAT_TYPE_UNSPECIFIED",
		1: "MALWARE",
		2: "SOCIAL_ENGINEERING",
		3: "UNWANTED_SOFTWARE",
		4: "POTENTIALLY_HARMFUL_APPLICATION",
	}
	ThreatType_value = map[string]int32{
		"THREAT_TYPE_UNSPECIFIED":         0,
		"MALWARE":                         1,
		"SOCIAL_ENGINEERING":              2,
		"UNWANTED_SOFTWARE":               3,
		"POTENTIALLY_HARMFUL_APPLICATION": 4,
	}
)

func (x ThreatType) Enum() *ThreatType {
	p := new(ThreatType)
	*p = x
	return p
}

func (x ThreatType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ThreatType) Descriptor() protoreflect.EnumDescriptor {
	return file_safebrowsing_proto_enumTypes[0].Descriptor()
}

func (ThreatType) Type() protoreflect.EnumType {
	return &file_safebrowsing_proto_enumTypes[0]
}

func (x ThreatType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ThreatType.Descriptor instead.
func (ThreatType) EnumDescriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{0}
}

// Types of platforms.
type PlatformType int32

const (
	// Unknown platform.
	PlatformType_PLATFORM_TYPE_UNSPECIFIED PlatformType = 0
	// Threat posed to Windows.
	PlatformType_WINDOWS PlatformType = 1
	// Threat posed to Linux.
	PlatformType_LINUX PlatformType = 2
	// Threat posed to Android.
	PlatformType_ANDROID PlatformType = 3
	// Threat posed to OSX.
	PlatformType_OSX PlatformType = 4
	// Threat posed to iOS.
	PlatformType_IOS PlatformType = 5
	// Threat posed to at least one of the defined platforms.
	PlatformType_ANY_PLATFORM PlatformType = 6
	// Threat posed to all defined platforms.
	PlatformType_ALL_PLATFORMS PlatformType = 7
	// Threat posed to Chrome.
	PlatformType_CHROME PlatformType = 8
)

// Enum value maps for PlatformType.
var (
	PlatformType_name = map[int32]string{
		0: "PLATFORM_TYPE_UNSPECIFIED",
		1: "WINDOWS",
		2: "LINUX",
		3: "ANDROID",
		4: "OSX",
		5: "IOS",
		6: "ANY_PLATFORM",
		7: "ALL_PLATFORMS",
		8: "CHROME",
	}
	PlatformType_value = map[string]int32{
		"PLATFORM_TYPE_UNSPECIFIED": 0,
		"WINDOWS":                   1,
		"LINUX":                     2,
		"ANDROID":                   3,
		"OSX":                       4,
		"IOS":                       5,
		"ANY_PLATFORM":              6,
		"ALL_PLATFORMS":             7,
		"CHROME":                    8,
	}
)

func (x PlatformType) Enum() *PlatformType {
	p := new(PlatformType)
	*p = x
	return p
}

func (x PlatformType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PlatformType) Descriptor() protoreflect.EnumDescriptor {
	return file_safebrowsing_proto_enumTypes[1].Descriptor()
}

func (PlatformType) Type() protoreflect.EnumType {
	return &file_safebrowsing_proto_enumTypes[1]
}

func (x PlatformType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PlatformType.Descriptor instead.
func (PlatformType) EnumDescriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{1}
}

// The ways in which threat entry sets can be compressed.
type CompressionType int32

const (
	// Unknown.
	CompressionType_COMPRESSION_TYPE_UNSPECIFIED CompressionType = 0
	// Raw, uncompressed data.
	CompressionType_RAW CompressionType = 1
	// Rice-Golomb encoded data.
	CompressionType_RICE CompressionType = 2
)

// Enum value maps for CompressionType.
var (
	CompressionType_name = map[int32]string{
		0: "COMPRESSION_TYPE_UNSPECIFIED",
		1: "RAW",
		2: "RICE",
	}
	CompressionType_value = map[string]int32{
		"COMPRESSION_TYPE_UNSPECIFIED": 0,
		"RAW":                          1,
		"RICE":                         2,
	}
)

func (x CompressionType) Enum() *CompressionType {
	p := new(CompressionType)
	*p = x
	return p
}

func (x CompressionType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CompressionType) Descriptor() protoreflect.EnumDescriptor {
	return file_safebrowsing_proto_enumTypes[2].Descriptor()
}

func (CompressionType) Type() protoreflect.EnumType {
	return &file_safebrowsing_proto_enumTypes[2]
}

func (x CompressionType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CompressionType.Descriptor instead.
func (CompressionType) EnumDescriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{2}
}

// Types of entries that pose threats. Threat lists are collections of entries
// of a single type.
type ThreatEntryType int32

const (
	// Unspecified.
	ThreatEntryType_THREAT_ENTRY_TYPE_UNSPECIFIED ThreatEntryType = 0
	// A URL.
	ThreatEntryType_URL ThreatEntryType = 1
	// An executable program.
	ThreatEntryType_EXECUTABLE ThreatEntryType = 2
	// An IP range.
	ThreatEntryType_IP_RANGE ThreatEntryType = 3
)

// Enum value maps for ThreatEntryType.
var (
	ThreatEntryType_name = map[int32]string{
		0: "THREAT_ENTRY_TYPE_UNSPECIFIED",
		1: "URL",
		2: "EXECUTABLE",
		3: "IP_RANGE",
	}
	ThreatEntryType_value = map[string]int32{
		"THREAT_ENTRY_TYPE_UNSPECIFIED": 0,
		"URL":                           1,
		"EXECUTABLE":                    2,
		"IP_RANGE":                      3,
	}
)

func (x ThreatEntryType) Enum() *ThreatEntryType {
	p := new(ThreatEntryType)
	*p = x
	return p
}

func (x ThreatEntryType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ThreatEntryType) Descriptor() protoreflect.EnumDescriptor {
	return file_safebrowsing_proto_enumTypes[3].Descriptor()
}

func (ThreatEntryType) Type() protoreflect.EnumType {
	return &file_safebrowsing_proto_enumTypes[3]
}

func (x ThreatEntryType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ThreatEntryType.Descriptor instead.
func (ThreatEntryType) EnumDescriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{3}
}

// The type of response sent to the client.
type FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType int32

const (
	// Unknown.
	FetchThreatListUpdatesResponse_ListUpdateResponse_RESPONSE_TYPE_UNSPECIFIED FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType = 0
	// Partial updates are applied to the client's existing local database.
	FetchThreatListUpdatesResponse_ListUpdateResponse_PARTIAL_UPDATE FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType = 1
	// Full updates replace the client's entire local database. This means
	// that either the client was seriously out-of-date or the client is
	// believed to be corrupt.
	FetchThreatListUpdatesResponse_ListUpdateResponse_FULL_UPDATE FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType = 2
)

// Enum value maps for FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType.
var (
	FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_name = map[int32]string{
		0: "RESPONSE_TYPE_UNSPECIFIED",
		1: "PARTIAL_UPDATE",
		2: "FULL_UPDATE",
	}
	FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_value = map[string]int32{
		"RESPONSE_TYPE_UNSPECIFIED": 0,
		"PARTIAL_UPDATE":            1,
		"FULL_UPDATE":               2,
	}
)

func (x FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType) Enum() *FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType {
	p := new(FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType)
	*p = x
	return p
}

func (x FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType) Descriptor() protoreflect.EnumDescriptor {
	return file_safebrowsing_proto_enumTypes[4].Descriptor()
}

func (FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType) Type() protoreflect.EnumType {
	return &file_safebrowsing_proto_enumTypes[4]
}

func (x FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType.Descriptor instead.
func (FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType) EnumDescriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{5, 0, 0}
}

// The information regarding one or more threats that a client submits when
// checking for matches in threat lists.
type ThreatInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The threat types to be checked.
	ThreatTypes []ThreatType `protobuf:"varint,1,rep,packed,name=threat_types,json=threatTypes,proto3,enum=main.ThreatType" json:"threat_types,omitempty"`
	// The platform types to be checked.
	PlatformTypes []PlatformType `protobuf:"varint,2,rep,packed,name=platform_types,json=platformTypes,proto3,enum=main.PlatformType" json:"platform_types,omitempty"`
	// The entry types to be checked.
	ThreatEntryTypes []ThreatEntryType `protobuf:"varint,4,rep,packed,name=threat_entry_types,json=threatEntryTypes,proto3,enum=main.ThreatEntryType" json:"threat_entry_types,omitempty"`
	// The threat entries to be checked.
	ThreatEntries []*ThreatEntry `protobuf:"bytes,3,rep,name=threat_entries,json=threatEntries,proto3" json:"threat_entries,omitempty"`
}

func (x *ThreatInfo) Reset() {
	*x = ThreatInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ThreatInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ThreatInfo) ProtoMessage() {}

func (x *ThreatInfo) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ThreatInfo.ProtoReflect.Descriptor instead.
func (*ThreatInfo) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{0}
}

func (x *ThreatInfo) GetThreatTypes() []ThreatType {
	if x != nil {
		return x.ThreatTypes
	}
	return nil
}

func (x *ThreatInfo) GetPlatformTypes() []PlatformType {
	if x != nil {
		return x.PlatformTypes
	}
	return nil
}

func (x *ThreatInfo) GetThreatEntryTypes() []ThreatEntryType {
	if x != nil {
		return x.ThreatEntryTypes
	}
	return nil
}

func (x *ThreatInfo) GetThreatEntries() []*ThreatEntry {
	if x != nil {
		return x.ThreatEntries
	}
	return nil
}

// A match when checking a threat entry in the Safe Browsing threat lists.
type ThreatMatch struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The threat type matching this threat.
	ThreatType ThreatType `protobuf:"varint,1,opt,name=threat_type,json=threatType,proto3,enum=main.ThreatType" json:"threat_type,omitempty"`
	// The platform type matching this threat.
	PlatformType PlatformType `protobuf:"varint,2,opt,name=platform_type,json=platformType,proto3,enum=main.PlatformType" json:"platform_type,omitempty"`
	// The threat entry type matching this threat.
	ThreatEntryType ThreatEntryType `protobuf:"varint,6,opt,name=threat_entry_type,json=threatEntryType,proto3,enum=main.ThreatEntryType" json:"threat_entry_type,omitempty"`
	// The threat matching this threat.
	Threat *ThreatEntry `protobuf:"bytes,3,opt,name=threat,proto3" json:"threat,omitempty"`
	// Optional metadata associated with this threat.
	ThreatEntryMetadata *ThreatEntryMetadata `protobuf:"bytes,4,opt,name=threat_entry_metadata,json=threatEntryMetadata,proto3" json:"threat_entry_metadata,omitempty"`
	// The cache lifetime for the returned match. Clients must not cache this
	// response for more than this duration to avoid false positives.
	CacheDuration *duration.Duration `protobuf:"bytes,5,opt,name=cache_duration,json=cacheDuration,proto3" json:"cache_duration,omitempty"`
}

func (x *ThreatMatch) Reset() {
	*x = ThreatMatch{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ThreatMatch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ThreatMatch) ProtoMessage() {}

func (x *ThreatMatch) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ThreatMatch.ProtoReflect.Descriptor instead.
func (*ThreatMatch) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{1}
}

func (x *ThreatMatch) GetThreatType() ThreatType {
	if x != nil {
		return x.ThreatType
	}
	return ThreatType_THREAT_TYPE_UNSPECIFIED
}

func (x *ThreatMatch) GetPlatformType() PlatformType {
	if x != nil {
		return x.PlatformType
	}
	return PlatformType_PLATFORM_TYPE_UNSPECIFIED
}

func (x *ThreatMatch) GetThreatEntryType() ThreatEntryType {
	if x != nil {
		return x.ThreatEntryType
	}
	return ThreatEntryType_THREAT_ENTRY_TYPE_UNSPECIFIED
}

func (x *ThreatMatch) GetThreat() *ThreatEntry {
	if x != nil {
		return x.Threat
	}
	return nil
}

func (x *ThreatMatch) GetThreatEntryMetadata() *ThreatEntryMetadata {
	if x != nil {
		return x.ThreatEntryMetadata
	}
	return nil
}

func (x *ThreatMatch) GetCacheDuration() *duration.Duration {
	if x != nil {
		return x.CacheDuration
	}
	return nil
}

// Request to check entries against lists.
type FindThreatMatchesRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The client metadata.
	Client *ClientInfo `protobuf:"bytes,1,opt,name=client,proto3" json:"client,omitempty"`
	// The lists and entries to be checked for matches.
	ThreatInfo *ThreatInfo `protobuf:"bytes,2,opt,name=threat_info,json=threatInfo,proto3" json:"threat_info,omitempty"`
}

func (x *FindThreatMatchesRequest) Reset() {
	*x = FindThreatMatchesRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FindThreatMatchesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FindThreatMatchesRequest) ProtoMessage() {}

func (x *FindThreatMatchesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FindThreatMatchesRequest.ProtoReflect.Descriptor instead.
func (*FindThreatMatchesRequest) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{2}
}

func (x *FindThreatMatchesRequest) GetClient() *ClientInfo {
	if x != nil {
		return x.Client
	}
	return nil
}

func (x *FindThreatMatchesRequest) GetThreatInfo() *ThreatInfo {
	if x != nil {
		return x.ThreatInfo
	}
	return nil
}

// Response type for requests to find threat matches.
type FindThreatMatchesResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The threat list matches.
	Matches []*ThreatMatch `protobuf:"bytes,1,rep,name=matches,proto3" json:"matches,omitempty"`
}

func (x *FindThreatMatchesResponse) Reset() {
	*x = FindThreatMatchesResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FindThreatMatchesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FindThreatMatchesResponse) ProtoMessage() {}

func (x *FindThreatMatchesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FindThreatMatchesResponse.ProtoReflect.Descriptor instead.
func (*FindThreatMatchesResponse) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{3}
}

func (x *FindThreatMatchesResponse) GetMatches() []*ThreatMatch {
	if x != nil {
		return x.Matches
	}
	return nil
}

// Describes a Safe Browsing API update request. Clients can request updates for
// multiple lists in a single request.
// NOTE: Field index 2 is unused.
type FetchThreatListUpdatesRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The client metadata.
	Client *ClientInfo `protobuf:"bytes,1,opt,name=client,proto3" json:"client,omitempty"`
	// The requested threat list updates.
	ListUpdateRequests []*FetchThreatListUpdatesRequest_ListUpdateRequest `protobuf:"bytes,3,rep,name=list_update_requests,json=listUpdateRequests,proto3" json:"list_update_requests,omitempty"`
}

func (x *FetchThreatListUpdatesRequest) Reset() {
	*x = FetchThreatListUpdatesRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FetchThreatListUpdatesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchThreatListUpdatesRequest) ProtoMessage() {}

func (x *FetchThreatListUpdatesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchThreatListUpdatesRequest.ProtoReflect.Descriptor instead.
func (*FetchThreatListUpdatesRequest) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{4}
}

func (x *FetchThreatListUpdatesRequest) GetClient() *ClientInfo {
	if x != nil {
		return x.Client
	}
	return nil
}

func (x *FetchThreatListUpdatesRequest) GetListUpdateRequests() []*FetchThreatListUpdatesRequest_ListUpdateRequest {
	if x != nil {
		return x.ListUpdateRequests
	}
	return nil
}

// Response type for threat list update requests.
type FetchThreatListUpdatesResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The list updates requested by the clients.
	ListUpdateResponses []*FetchThreatListUpdatesResponse_ListUpdateResponse `protobuf:"bytes,1,rep,name=list_update_responses,json=listUpdateResponses,proto3" json:"list_update_responses,omitempty"`
	// The minimum duration the client must wait before issuing any update
	// request. If this field is not set clients may update as soon as they want.
	MinimumWaitDuration *duration.Duration `protobuf:"bytes,2,opt,name=minimum_wait_duration,json=minimumWaitDuration,proto3" json:"minimum_wait_duration,omitempty"`
}

func (x *FetchThreatListUpdatesResponse) Reset() {
	*x = FetchThreatListUpdatesResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FetchThreatListUpdatesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchThreatListUpdatesResponse) ProtoMessage() {}

func (x *FetchThreatListUpdatesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchThreatListUpdatesResponse.ProtoReflect.Descriptor instead.
func (*FetchThreatListUpdatesResponse) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{5}
}

func (x *FetchThreatListUpdatesResponse) GetListUpdateResponses() []*FetchThreatListUpdatesResponse_ListUpdateResponse {
	if x != nil {
		return x.ListUpdateResponses
	}
	return nil
}

func (x *FetchThreatListUpdatesResponse) GetMinimumWaitDuration() *duration.Duration {
	if x != nil {
		return x.MinimumWaitDuration
	}
	return nil
}

// Request to return full hashes matched by the provided hash prefixes.
type FindFullHashesRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The client metadata.
	Client *ClientInfo `protobuf:"bytes,1,opt,name=client,proto3" json:"client,omitempty"`
	// The current client states for each of the client's local threat lists.
	ClientStates [][]byte `protobuf:"bytes,2,rep,name=client_states,json=clientStates,proto3" json:"client_states,omitempty"`
	// The lists and hashes to be checked.
	ThreatInfo *ThreatInfo `protobuf:"bytes,3,opt,name=threat_info,json=threatInfo,proto3" json:"threat_info,omitempty"`
}

func (x *FindFullHashesRequest) Reset() {
	*x = FindFullHashesRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FindFullHashesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FindFullHashesRequest) ProtoMessage() {}

func (x *FindFullHashesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FindFullHashesRequest.ProtoReflect.Descriptor instead.
func (*FindFullHashesRequest) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{6}
}

func (x *FindFullHashesRequest) GetClient() *ClientInfo {
	if x != nil {
		return x.Client
	}
	return nil
}

func (x *FindFullHashesRequest) GetClientStates() [][]byte {
	if x != nil {
		return x.ClientStates
	}
	return nil
}

func (x *FindFullHashesRequest) GetThreatInfo() *ThreatInfo {
	if x != nil {
		return x.ThreatInfo
	}
	return nil
}

// Response type for requests to find full hashes.
type FindFullHashesResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The full hashes that matched the requested prefixes.
	Matches []*ThreatMatch `protobuf:"bytes,1,rep,name=matches,proto3" json:"matches,omitempty"`
	// The minimum duration the client must wait before issuing any find hashes
	// request. If this field is not set, clients can issue a request as soon as
	// they want.
	MinimumWaitDuration *duration.Duration `protobuf:"bytes,2,opt,name=minimum_wait_duration,json=minimumWaitDuration,proto3" json:"minimum_wait_duration,omitempty"`
	// For requested entities that did not match the threat list, how long to
	// cache the response.
	NegativeCacheDuration *duration.Duration `protobuf:"bytes,3,opt,name=negative_cache_duration,json=negativeCacheDuration,proto3" json:"negative_cache_duration,omitempty"`
}

func (x *FindFullHashesResponse) Reset() {
	*x = FindFullHashesResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FindFullHashesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FindFullHashesResponse) ProtoMessage() {}

func (x *FindFullHashesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FindFullHashesResponse.ProtoReflect.Descriptor instead.
func (*FindFullHashesResponse) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{7}
}

func (x *FindFullHashesResponse) GetMatches() []*ThreatMatch {
	if x != nil {
		return x.Matches
	}
	return nil
}

func (x *FindFullHashesResponse) GetMinimumWaitDuration() *duration.Duration {
	if x != nil {
		return x.MinimumWaitDuration
	}
	return nil
}

func (x *FindFullHashesResponse) GetNegativeCacheDuration() *duration.Duration {
	if x != nil {
		return x.NegativeCacheDuration
	}
	return nil
}

// The client metadata associated with Safe Browsing API requests.
type ClientInfo struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A client ID that (hopefully) uniquely identifies the client implementation
	// of the Safe Browsing API.
	ClientId string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"client_id,omitempty"`
	// The version of the client implementation.
	ClientVersion string `protobuf:"bytes,2,opt,name=client_version,json=clientVersion,proto3" json:"client_version,omitempty"`
}

func (x *ClientInfo) Reset() {
	*x = ClientInfo{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ClientInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClientInfo) ProtoMessage() {}

func (x *ClientInfo) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClientInfo.ProtoReflect.Descriptor instead.
func (*ClientInfo) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{8}
}

func (x *ClientInfo) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *ClientInfo) GetClientVersion() string {
	if x != nil {
		return x.ClientVersion
	}
	return ""
}

// The expected state of a client's local database.
type Checksum struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The SHA256 hash of the client state; that is, of the sorted list of all
	// hashes present in the database.
	Sha256 []byte `protobuf:"bytes,1,opt,name=sha256,proto3" json:"sha256,omitempty"`
}

func (x *Checksum) Reset() {
	*x = Checksum{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *Checksum) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Checksum) ProtoMessage() {}

func (x *Checksum) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Checksum.ProtoReflect.Descriptor instead.
func (*Checksum) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{9}
}

func (x *Checksum) GetSha256() []byte {
	if x != nil {
		return x.Sha256
	}
	return nil
}

// An individual threat; for example, a malicious URL or its hash
// representation. Only one of these fields should be set.
type ThreatEntry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// A hash prefix, consisting of the most significant 4-32 bytes of a SHA256
	// hash.
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// A URL.
	Url string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
}

func (x *ThreatEntry) Reset() {
	*x = ThreatEntry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[10]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ThreatEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ThreatEntry) ProtoMessage() {}

func (x *ThreatEntry) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[10]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ThreatEntry.ProtoReflect.Descriptor instead.
func (*ThreatEntry) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{10}
}

func (x *ThreatEntry) GetHash() []byte {
	if x != nil {
		return x.Hash
	}
	return nil
}

func (x *ThreatEntry) GetUrl() string {
	if x != nil {
		return x.Url
	}
	return ""
}

// A set of threats that should be added or removed from a client's local
// database.
type ThreatEntrySet struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The compression type for the entries in this set.
	CompressionType CompressionType `protobuf:"varint,1,opt,name=compression_type,json=compressionType,proto3,enum=main.CompressionType" json:"compression_type,omitempty"`
	// The raw SHA256-formatted entries.
	RawHashes *RawHashes `protobuf:"bytes,2,opt,name=raw_hashes,json=rawHashes,proto3" json:"raw_hashes,omitempty"`
	// The raw removal indices for a local list.
	RawIndices *RawIndices `protobuf:"bytes,3,opt,name=raw_indices,json=rawIndices,proto3" json:"raw_indices,omitempty"`
	// The encoded 4-byte prefixes of SHA256-formatted entries, using a
	// Golomb-Rice encoding.
	RiceHashes *RiceDeltaEncoding `protobuf:"bytes,4,opt,name=rice_hashes,json=riceHashes,proto3" json:"rice_hashes,omitempty"`
	// The encoded local, lexicographically-sorted list indices, using a
	// Golomb-Rice encoding. Used for sending compressed removal indices.
	RiceIndices *RiceDeltaEncoding `protobuf:"bytes,5,opt,name=rice_indices,json=riceIndices,proto3" json:"rice_indices,omitempty"`
}

func (x *ThreatEntrySet) Reset() {
	*x = ThreatEntrySet{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[11]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ThreatEntrySet) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ThreatEntrySet) ProtoMessage() {}

func (x *ThreatEntrySet) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[11]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ThreatEntrySet.ProtoReflect.Descriptor instead.
func (*ThreatEntrySet) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{11}
}

func (x *ThreatEntrySet) GetCompressionType() CompressionType {
	if x != nil {
		return x.CompressionType
	}
	return CompressionType_COMPRESSION_TYPE_UNSPECIFIED
}

func (x *ThreatEntrySet) GetRawHashes() *RawHashes {
	if x != nil {
		return x.RawHashes
	}
	return nil
}

func (x *ThreatEntrySet) GetRawIndices() *RawIndices {
	if x != nil {
		return x.RawIndices
	}
	return nil
}

func (x *ThreatEntrySet) GetRiceHashes() *RiceDeltaEncoding {
	if x != nil {
		return x.RiceHashes
	}
	return nil
}

func (x *ThreatEntrySet) GetRiceIndices() *RiceDeltaEncoding {
	if x != nil {
		return x.RiceIndices
	}
	return nil
}

// A set of raw indices to remove from a local list.
type RawIndices struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The indices to remove from a lexicographically-sorted local list.
	Indices []int32 `protobuf:"varint,1,rep,packed,name=indices,proto3" json:"indices,omitempty"`
}

func (x *RawIndices) Reset() {
	*x = RawIndices{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[12]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RawIndices) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawIndices) ProtoMessage() {}

func (x *RawIndices) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[12]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawIndices.ProtoReflect.Descriptor instead.
func (*RawIndices) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{12}
}

func (x *RawIndices) GetIndices() []int32 {
	if x != nil {
		return x.Indices
	}
	return nil
}

// The uncompressed threat entries in hash format of a particular prefix length.
// Hashes can be anywhere from 4 to 32 bytes in size. A large majority are 4
// bytes, but some hashes are lengthened if they collide with the hash of a
// popular URL.
//
// Used for sending ThreatEntrySet to clients that do not support compression,
// or when sending non-4-byte hashes to clients that do support compression.
type RawHashes struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The number of bytes for each prefix encoded below.  This field can be
	// anywhere from 4 (shortest prefix) to 32 (full SHA256 hash).
	PrefixSize int32 `protobuf:"varint,1,opt,name=prefix_size,json=prefixSize,proto3" json:"prefix_size,omitempty"`
	// The hashes, all concatenated into one long string.  Each hash has a prefix
	// size of |prefix_size| above. Hashes are sorted in lexicographic order.
	RawHashes []byte `protobuf:"bytes,2,opt,name=raw_hashes,json=rawHashes,proto3" json:"raw_hashes,omitempty"`
}

func (x *RawHashes) Reset() {
	*x = RawHashes{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[13]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RawHashes) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RawHashes) ProtoMessage() {}

func (x *RawHashes) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[13]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RawHashes.ProtoReflect.Descriptor instead.
func (*RawHashes) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{13}
}

func (x *RawHashes) GetPrefixSize() int32 {
	if x != nil {
		return x.PrefixSize
	}
	return 0
}

func (x *RawHashes) GetRawHashes() []byte {
	if x != nil {
		return x.RawHashes
	}
	return nil
}

// The Rice-Golomb encoded data. Used for sending compressed 4-byte hashes or
// compressed removal indices.
type RiceDeltaEncoding struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The offset of the first entry in the encoded data, or, if only a single
	// integer was encoded, that single integer's value.
	FirstValue int64 `protobuf:"varint,1,opt,name=first_value,json=firstValue,proto3" json:"first_value,omitempty"`
	// The Golomb-Rice parameter which is a number between 2 and 28. This field
	// is missing (that is, zero) if num_entries is zero.
	RiceParameter int32 `protobuf:"varint,2,opt,name=rice_parameter,json=riceParameter,proto3" json:"rice_parameter,omitempty"`
	// The number of entries that are delta encoded in the encoded data. If only a
	// single integer was encoded, this will be zero and the single value will be
	// stored in first_value.
	NumEntries int32 `protobuf:"varint,3,opt,name=num_entries,json=numEntries,proto3" json:"num_entries,omitempty"`
	// The encoded deltas that are encoded using the Golomb-Rice coder.
	EncodedData []byte `protobuf:"bytes,4,opt,name=encoded_data,json=encodedData,proto3" json:"encoded_data,omitempty"`
}

func (x *RiceDeltaEncoding) Reset() {
	*x = RiceDeltaEncoding{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[14]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *RiceDeltaEncoding) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RiceDeltaEncoding) ProtoMessage() {}

func (x *RiceDeltaEncoding) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[14]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RiceDeltaEncoding.ProtoReflect.Descriptor instead.
func (*RiceDeltaEncoding) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{14}
}

func (x *RiceDeltaEncoding) GetFirstValue() int64 {
	if x != nil {
		return x.FirstValue
	}
	return 0
}

func (x *RiceDeltaEncoding) GetRiceParameter() int32 {
	if x != nil {
		return x.RiceParameter
	}
	return 0
}

func (x *RiceDeltaEncoding) GetNumEntries() int32 {
	if x != nil {
		return x.NumEntries
	}
	return 0
}

func (x *RiceDeltaEncoding) GetEncodedData() []byte {
	if x != nil {
		return x.EncodedData
	}
	return nil
}

// The metadata associated with a specific threat entry. The client is expected
// to know the metadata key/value pairs associated with each threat type.
type ThreatEntryMetadata struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The metadata entries.
	Entries []*ThreatEntryMetadata_MetadataEntry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (x *ThreatEntryMetadata) Reset() {
	*x = ThreatEntryMetadata{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[15]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ThreatEntryMetadata) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ThreatEntryMetadata) ProtoMessage() {}

func (x *ThreatEntryMetadata) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[15]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ThreatEntryMetadata.ProtoReflect.Descriptor instead.
func (*ThreatEntryMetadata) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{15}
}

func (x *ThreatEntryMetadata) GetEntries() []*ThreatEntryMetadata_MetadataEntry {
	if x != nil {
		return x.Entries
	}
	return nil
}

// Describes an individual threat list. A list is defined by three parameters:
// the type of threat posed, the type of platform targeted by the threat, and
// the type of entries in the list.
type ThreatListDescriptor struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The threat type posed by the list's entries.
	ThreatType ThreatType `protobuf:"varint,1,opt,name=threat_type,json=threatType,proto3,enum=main.ThreatType" json:"threat_type,omitempty"`
	// The platform type targeted by the list's entries.
	PlatformType PlatformType `protobuf:"varint,2,opt,name=platform_type,json=platformType,proto3,enum=main.PlatformType" json:"platform_type,omitempty"`
	// The entry types contained in the list.
	ThreatEntryType ThreatEntryType `protobuf:"varint,3,opt,name=threat_entry_type,json=threatEntryType,proto3,enum=main.ThreatEntryType" json:"threat_entry_type,omitempty"`
}

func (x *ThreatListDescriptor) Reset() {
	*x = ThreatListDescriptor{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[16]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ThreatListDescriptor) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ThreatListDescriptor) ProtoMessage() {}

func (x *ThreatListDescriptor) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[16]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ThreatListDescriptor.ProtoReflect.Descriptor instead.
func (*ThreatListDescriptor) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{16}
}

func (x *ThreatListDescriptor) GetThreatType() ThreatType {
	if x != nil {
		return x.ThreatType
	}
	return ThreatType_THREAT_TYPE_UNSPECIFIED
}

func (x *ThreatListDescriptor) GetPlatformType() PlatformType {
	if x != nil {
		return x.PlatformType
	}
	return PlatformType_PLATFORM_TYPE_UNSPECIFIED
}

func (x *ThreatListDescriptor) GetThreatEntryType() ThreatEntryType {
	if x != nil {
		return x.ThreatEntryType
	}
	return ThreatEntryType_THREAT_ENTRY_TYPE_UNSPECIFIED
}

// A collection of lists available for download by the client.
type ListThreatListsResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The lists available for download by the client.
	ThreatLists []*ThreatListDescriptor `protobuf:"bytes,1,rep,name=threat_lists,json=threatLists,proto3" json:"threat_lists,omitempty"`
}

func (x *ListThreatListsResponse) Reset() {
	*x = ListThreatListsResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[17]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ListThreatListsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListThreatListsResponse) ProtoMessage() {}

func (x *ListThreatListsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[17]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListThreatListsResponse.ProtoReflect.Descriptor instead.
func (*ListThreatListsResponse) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{17}
}

func (x *ListThreatListsResponse) GetThreatLists() []*ThreatListDescriptor {
	if x != nil {
		return x.ThreatLists
	}
	return nil
}

// A single list update request.
type FetchThreatListUpdatesRequest_ListUpdateRequest struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The type of threat posed by entries present in the list.
	ThreatType ThreatType `protobuf:"varint,1,opt,name=threat_type,json=threatType,proto3,enum=main.ThreatType" json:"threat_type,omitempty"`
	// The type of platform at risk by entries present in the list.
	PlatformType PlatformType `protobuf:"varint,2,opt,name=platform_type,json=platformType,proto3,enum=main.PlatformType" json:"platform_type,omitempty"`
	// The types of entries present in the list.
	ThreatEntryType ThreatEntryType `protobuf:"varint,5,opt,name=threat_entry_type,json=threatEntryType,proto3,enum=main.ThreatEntryType" json:"threat_entry_type,omitempty"`
	// The current state of the client for the requested list (the encrypted
	// ClientState that was sent to the client from the previous update
	// request).
	State []byte `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
	// The constraints associated with this request.
	Constraints *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints `protobuf:"bytes,4,opt,name=constraints,proto3" json:"constraints,omitempty"`
}

func (x *FetchThreatListUpdatesRequest_ListUpdateRequest) Reset() {
	*x = FetchThreatListUpdatesRequest_ListUpdateRequest{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[18]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FetchThreatListUpdatesRequest_ListUpdateRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchThreatListUpdatesRequest_ListUpdateRequest) ProtoMessage() {}

func (x *FetchThreatListUpdatesRequest_ListUpdateRequest) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[18]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchThreatListUpdatesRequest_ListUpdateRequest.ProtoReflect.Descriptor instead.
func (*FetchThreatListUpdatesRequest_ListUpdateRequest) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{4, 0}
}

func (x *FetchThreatListUpdatesRequest_ListUpdateRequest) GetThreatType() ThreatType {
	if x != nil {
		return x.ThreatType
	}
	return ThreatType_THREAT_TYPE_UNSPECIFIED
}

func (x *FetchThreatListUpdatesRequest_ListUpdateRequest) GetPlatformType() PlatformType {
	if x != nil {
		return x.PlatformType
	}
	return PlatformType_PLATFORM_TYPE_UNSPECIFIED
}

func (x *FetchThreatListUpdatesRequest_ListUpdateRequest) GetThreatEntryType() ThreatEntryType {
	if x != nil {
		return x.ThreatEntryType
	}
	return ThreatEntryType_THREAT_ENTRY_TYPE_UNSPECIFIED
}

func (x *FetchThreatListUpdatesRequest_ListUpdateRequest) GetState() []byte {
	if x != nil {
		return x.State
	}
	return nil
}

func (x *FetchThreatListUpdatesRequest_ListUpdateRequest) GetConstraints() *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints {
	if x != nil {
		return x.Constraints
	}
	return nil
}

// The constraints for this update.
type FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The maximum size in number of entries. The update will not contain more
	// entries than this value.  This should be a power of 2 between 2**10 and
	// 2**20.  If zero, no update size limit is set.
	MaxUpdateEntries int32 `protobuf:"varint,1,opt,name=max_update_entries,json=maxUpdateEntries,proto3" json:"max_update_entries,omitempty"`
	// Sets the maximum number of entries that the client is willing to have
	// in the local database. This should be a power of 2 between 2**10 and
	// 2**20. If zero, no database size limit is set.
	MaxDatabaseEntries int32 `protobuf:"varint,2,opt,name=max_database_entries,json=maxDatabaseEntries,proto3" json:"max_database_entries,omitempty"`
	// Requests the list for a specific geographic location. If not set the
	// server may pick that value based on the user's IP address. Expects ISO
	// 3166-1 alpha-2 format.
	Region string `protobuf:"bytes,3,opt,name=region,proto3" json:"region,omitempty"`
	// The compression types supported by the client.
	SupportedCompressions []CompressionType `protobuf:"varint,4,rep,packed,name=supported_compressions,json=supportedCompressions,proto3,enum=main.CompressionType" json:"supported_compressions,omitempty"`
}

func (x *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) Reset() {
	*x = FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[19]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) ProtoMessage() {}

func (x *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[19]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints.ProtoReflect.Descriptor instead.
func (*FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{4, 0, 0}
}

func (x *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) GetMaxUpdateEntries() int32 {
	if x != nil {
		return x.MaxUpdateEntries
	}
	return 0
}

func (x *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) GetMaxDatabaseEntries() int32 {
	if x != nil {
		return x.MaxDatabaseEntries
	}
	return 0
}

func (x *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) GetRegion() string {
	if x != nil {
		return x.Region
	}
	return ""
}

func (x *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) GetSupportedCompressions() []CompressionType {
	if x != nil {
		return x.SupportedCompressions
	}
	return nil
}

// An update to an individual list.
type FetchThreatListUpdatesResponse_ListUpdateResponse struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The threat type for which data is returned.
	ThreatType ThreatType `protobuf:"varint,1,opt,name=threat_type,json=threatType,proto3,enum=main.ThreatType" json:"threat_type,omitempty"`
	// The format of the threats.
	ThreatEntryType ThreatEntryType `protobuf:"varint,2,opt,name=threat_entry_type,json=threatEntryType,proto3,enum=main.ThreatEntryType" json:"threat_entry_type,omitempty"`
	// The platform type for which data is returned.
	PlatformType PlatformType `protobuf:"varint,3,opt,name=platform_type,json=platformType,proto3,enum=main.PlatformType" json:"platform_type,omitempty"`
	// The type of response. This may indicate that an action is required by the
	// client when the response is received.
	ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType `protobuf:"varint,4,opt,name=response_type,json=responseType,proto3,enum=main.FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType" json:"response_type,omitempty"`
	// A set of entries to add to a local threat type's list. Repeated to allow
	// for a combination of compressed and raw data to be sent in a single
	// response.
	Additions []*ThreatEntrySet `protobuf:"bytes,5,rep,name=additions,proto3" json:"additions,omitempty"`
	// A set of entries to remove from a local threat type's list. Repeated for
	// the same reason as above.
	Removals []*ThreatEntrySet `protobuf:"bytes,6,rep,name=removals,proto3" json:"removals,omitempty"`
	// The new client state, in encrypted format. Opaque to clients.
	NewClientState []byte `protobuf:"bytes,7,opt,name=new_client_state,json=newClientState,proto3" json:"new_client_state,omitempty"`
	// The expected SHA256 hash of the client state; that is, of the sorted list
	// of all hashes present in the database after applying the provided update.
	// If the client state doesn't match the expected state, the client must
	// disregard this update and retry later.
	Checksum *Checksum `protobuf:"bytes,8,opt,name=checksum,proto3" json:"checksum,omitempty"`
}

func (x *FetchThreatListUpdatesResponse_ListUpdateResponse) Reset() {
	*x = FetchThreatListUpdatesResponse_ListUpdateResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[20]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *FetchThreatListUpdatesResponse_ListUpdateResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FetchThreatListUpdatesResponse_ListUpdateResponse) ProtoMessage() {}

func (x *FetchThreatListUpdatesResponse_ListUpdateResponse) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[20]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FetchThreatListUpdatesResponse_ListUpdateResponse.ProtoReflect.Descriptor instead.
func (*FetchThreatListUpdatesResponse_ListUpdateResponse) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{5, 0}
}

func (x *FetchThreatListUpdatesResponse_ListUpdateResponse) GetThreatType() ThreatType {
	if x != nil {
		return x.ThreatType
	}
	return ThreatType_THREAT_TYPE_UNSPECIFIED
}

func (x *FetchThreatListUpdatesResponse_ListUpdateResponse) GetThreatEntryType() ThreatEntryType {
	if x != nil {
		return x.ThreatEntryType
	}
	return ThreatEntryType_THREAT_ENTRY_TYPE_UNSPECIFIED
}

func (x *FetchThreatListUpdatesResponse_ListUpdateResponse) GetPlatformType() PlatformType {
	if x != nil {
		return x.PlatformType
	}
	return PlatformType_PLATFORM_TYPE_UNSPECIFIED
}

func (x *FetchThreatListUpdatesResponse_ListUpdateResponse) GetResponseType() FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType {
	if x != nil {
		return x.ResponseType
	}
	return FetchThreatListUpdatesResponse_ListUpdateResponse_RESPONSE_TYPE_UNSPECIFIED
}

func (x *FetchThreatListUpdatesResponse_ListUpdateResponse) GetAdditions() []*ThreatEntrySet {
	if x != nil {
		return x.Additions
	}
	return nil
}

func (x *FetchThreatListUpdatesResponse_ListUpdateResponse) GetRemovals() []*ThreatEntrySet {
	if x != nil {
		return x.Removals
	}
	return nil
}

func (x *FetchThreatListUpdatesResponse_ListUpdateResponse) GetNewClientState() []byte {
	if x != nil {
		return x.NewClientState
	}
	return nil
}

func (x *FetchThreatListUpdatesResponse_ListUpdateResponse) GetChecksum() *Checksum {
	if x != nil {
		return x.Checksum
	}
	return nil
}

// A single metadata entry.
type ThreatEntryMetadata_MetadataEntry struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields

	// The metadata entry key.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// The metadata entry value.
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *ThreatEntryMetadata_MetadataEntry) Reset() {
	*x = ThreatEntryMetadata_MetadataEntry{}
	if protoimpl.UnsafeEnabled {
		mi := &file_safebrowsing_proto_msgTypes[21]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		ms.StoreMessageInfo(mi)
	}
}

func (x *ThreatEntryMetadata_MetadataEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ThreatEntryMetadata_MetadataEntry) ProtoMessage() {}

func (x *ThreatEntryMetadata_MetadataEntry) ProtoReflect() protoreflect.Message {
	mi := &file_safebrowsing_proto_msgTypes[21]
	if protoimpl.UnsafeEnabled && x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ThreatEntryMetadata_MetadataEntry.ProtoReflect.Descriptor instead.
func (*ThreatEntryMetadata_MetadataEntry) Descriptor() ([]byte, []int) {
	return file_safebrowsing_proto_rawDescGZIP(), []int{15, 0}
}

func (x *ThreatEntryMetadata_MetadataEntry) GetKey() []byte {
	if x != nil {
		return x.Key
	}
	return nil
}

func (x *ThreatEntryMetadata_MetadataEntry) GetValue() []byte {
	if x != nil {
		return x.Value
	}
	return nil
}

var File_safebrowsing_proto protoreflect.FileDescriptor

var file_safebrowsing_proto_rawDesc = []byte{
	0x0a, 0x12, 0x73, 0x61, 0x66, 0x65, 0x62, 0x72, 0x6f, 0x77, 0x73, 0x69, 0x6e, 0x67, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x12, 0x04, 0x6d, 0x61, 0x69, 0x6e, 0x1a, 0x1e, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f, 0x64, 0x75, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xfb, 0x01, 0x0a, 0x0a, 0x54,
	0x68, 0x72, 0x65, 0x61, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x33, 0x0a, 0x0c, 0x74, 0x68, 0x72,
	0x65, 0x61, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0e, 0x32,
	0x10, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x54, 0x79, 0x70,
	0x65, 0x52, 0x0b, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x54, 0x79, 0x70, 0x65, 0x73, 0x12, 0x39,
	0x0a, 0x0e, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x73,
	0x18, 0x02, 0x20, 0x03, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x50, 0x6c,
	0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0d, 0x70, 0x6c, 0x61, 0x74,
	0x66, 0x6f, 0x72, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x12, 0x43, 0x0a, 0x12, 0x74, 0x68, 0x72,
	0x65, 0x61, 0x74, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x79, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x73, 0x18,
	0x04, 0x20, 0x03, 0x28, 0x0e, 0x32, 0x15, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x54, 0x68, 0x72,
	0x65, 0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x54, 0x79, 0x70, 0x65, 0x52, 0x10, 0x74, 0x68,
	0x72, 0x65, 0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x54, 0x79, 0x70, 0x65, 0x73, 0x12, 0x38,
	0x0a, 0x0e, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73,
	0x18, 0x03, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x54, 0x68,
	0x72, 0x65, 0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x0d, 0x74, 0x68, 0x72, 0x65, 0x61,
	0x74, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x22, 0xf8, 0x02, 0x0a, 0x0b, 0x54, 0x68, 0x72,
	0x65, 0x61, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x12, 0x31, 0x0a, 0x0b, 0x74, 0x68, 0x72, 0x65,
	0x61, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x10, 0x2e,
	0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x54, 0x79, 0x70, 0x65, 0x52,
	0x0a, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x37, 0x0a, 0x0d, 0x70,
	0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01,
	0x28, 0x0e, 0x32, 0x12, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x50, 0x6c, 0x61, 0x74, 0x66, 0x6f,
	0x72, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0c, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d,
	0x54, 0x79, 0x70, 0x65, 0x12, 0x41, 0x0a, 0x11, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x5f, 0x65,
	0x6e, 0x74, 0x72, 0x79, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x15, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x45, 0x6e, 0x74,
	0x72, 0x79, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0f, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x54, 0x79, 0x70, 0x65, 0x12, 0x29, 0x0a, 0x06, 0x74, 0x68, 0x72, 0x65, 0x61,
	0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x54,
	0x68, 0x72, 0x65, 0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x06, 0x74, 0x68, 0x72, 0x65,
	0x61, 0x74, 0x12, 0x4d, 0x0a, 0x15, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x5f, 0x65, 0x6e, 0x74,
	0x72, 0x79, 0x5f, 0x6d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x18, 0x04, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x19, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x45,
	0x6e, 0x74, 0x72, 0x79, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x52, 0x13, 0x74, 0x68,
	0x72, 0x65, 0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74,
	0x61, 0x12, 0x40, 0x0a, 0x0e, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x64, 0x75, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67,
	0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x52, 0x0d, 0x63, 0x61, 0x63, 0x68, 0x65, 0x44, 0x75, 0x72, 0x61, 0x74,
	0x69, 0x6f, 0x6e, 0x22, 0x77, 0x0a, 0x18, 0x46, 0x69, 0x6e, 0x64, 0x54, 0x68, 0x72, 0x65, 0x61,
	0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12,
	0x28, 0x0a, 0x06, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x10, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x6e, 0x66,
	0x6f, 0x52, 0x06, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x12, 0x31, 0x0a, 0x0b, 0x74, 0x68, 0x72,
	0x65, 0x61, 0x74, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10,
	0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x49, 0x6e, 0x66, 0x6f,
	0x52, 0x0a, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x22, 0x48, 0x0a, 0x19,
	0x46, 0x69, 0x6e, 0x64, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x65,
	0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2b, 0x0a, 0x07, 0x6d, 0x61, 0x74,
	0x63, 0x68, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x61, 0x69,
	0x6e, 0x2e, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x07, 0x6d,
	0x61, 0x74, 0x63, 0x68, 0x65, 0x73, 0x22, 0xc8, 0x05, 0x0a, 0x1d, 0x46, 0x65, 0x74, 0x63, 0x68,
	0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
	0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x28, 0x0a, 0x06, 0x63, 0x6c, 0x69, 0x65,
	0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e,
	0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x06, 0x63, 0x6c, 0x69, 0x65,
	0x6e, 0x74, 0x12, 0x67, 0x0a, 0x14, 0x6c, 0x69, 0x73, 0x74, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74,
	0x65, 0x5f, 0x72, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x18, 0x03, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x35, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x46, 0x65, 0x74, 0x63, 0x68, 0x54, 0x68, 0x72,
	0x65, 0x61, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x73, 0x52, 0x65,
	0x71, 0x75, 0x65, 0x73, 0x74, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
	0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x52, 0x12, 0x6c, 0x69, 0x73, 0x74, 0x55, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x73, 0x1a, 0x93, 0x04, 0x0a, 0x11,
	0x4c, 0x69, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73,
	0x74, 0x12, 0x31, 0x0a, 0x0b, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x5f, 0x74, 0x79, 0x70, 0x65,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x10, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x54, 0x68,
	0x72, 0x65, 0x61, 0x74, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0a, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74,
	0x54, 0x79, 0x70, 0x65, 0x12, 0x37, 0x0a, 0x0d, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d,
	0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x6d, 0x61,
	0x69, 0x6e, 0x2e, 0x50, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x52,
	0x0c, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x12, 0x41, 0x0a,
	0x11, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x79, 0x5f, 0x74, 0x79,
	0x70, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x15, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e,
	0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x54, 0x79, 0x70, 0x65, 0x52,
	0x0f, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x54, 0x79, 0x70, 0x65,
	0x12, 0x14, 0x0a, 0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x05, 0x73, 0x74, 0x61, 0x74, 0x65, 0x12, 0x63, 0x0a, 0x0b, 0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72,
	0x61, 0x69, 0x6e, 0x74, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x41, 0x2e, 0x6d, 0x61,
	0x69, 0x6e, 0x2e, 0x46, 0x65, 0x74, 0x63, 0x68, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x4c, 0x69,
	0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74,
	0x2e, 0x4c, 0x69, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x71, 0x75, 0x65,
	0x73, 0x74, 0x2e, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x73, 0x52, 0x0b,
	0x63, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x73, 0x1a, 0xd3, 0x01, 0x0a, 0x0b,
	0x43, 0x6f, 0x6e, 0x73, 0x74, 0x72, 0x61, 0x69, 0x6e, 0x74, 0x73, 0x12, 0x2c, 0x0a, 0x12, 0x6d,
	0x61, 0x78, 0x5f, 0x75, 0x70, 0x64, 0x61, 0x74, 0x65, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65,
	0x73, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x10, 0x6d, 0x61, 0x78, 0x55, 0x70, 0x64, 0x61,
	0x74, 0x65, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x12, 0x30, 0x0a, 0x14, 0x6d, 0x61, 0x78,
	0x5f, 0x64, 0x61, 0x74, 0x61, 0x62, 0x61, 0x73, 0x65, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65,
	0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x05, 0x52, 0x12, 0x6d, 0x61, 0x78, 0x44, 0x61, 0x74, 0x61,
	0x62, 0x61, 0x73, 0x65, 0x45, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x12, 0x16, 0x0a, 0x06, 0x72,
	0x65, 0x67, 0x69, 0x6f, 0x6e, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06, 0x72, 0x65, 0x67,
	0x69, 0x6f, 0x6e, 0x12, 0x4c, 0x0a, 0x16, 0x73, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64,
	0x5f, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x04, 0x20,
	0x03, 0x28, 0x0e, 0x32, 0x15, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x72,
	0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x52, 0x15, 0x73, 0x75, 0x70, 0x70,
	0x6f, 0x72, 0x74, 0x65, 0x64, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e,
	0x73, 0x22, 0x9d, 0x06, 0x0a, 0x1e, 0x46, 0x65, 0x74, 0x63, 0x68, 0x54, 0x68, 0x72, 0x65, 0x61,
	0x74, 0x4c, 0x69, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x6b, 0x0a, 0x15, 0x6c, 0x69, 0x73, 0x74, 0x5f, 0x75, 0x70, 0x64,
	0x61, 0x74, 0x65, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x73, 0x18, 0x01, 0x20,
	0x03, 0x28, 0x0b, 0x32, 0x37, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x46, 0x65, 0x74, 0x63, 0x68,
	0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65,
	0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x55, 0x70,
	0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x52, 0x13, 0x6c, 0x69,
	0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65,
	0x73, 0x12, 0x4d, 0x0a, 0x15, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x5f, 0x77, 0x61, 0x69,
	0x74, 0x5f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b,
	0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62,
	0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52, 0x13, 0x6d, 0x69, 0x6e,
	0x69, 0x6d, 0x75, 0x6d, 0x57, 0x61, 0x69, 0x74, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x1a, 0xbe, 0x04, 0x0a, 0x12, 0x4c, 0x69, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52,
	0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x31, 0x0a, 0x0b, 0x74, 0x68, 0x72, 0x65, 0x61,
	0x74, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x10, 0x2e, 0x6d,
	0x61, 0x69, 0x6e, 0x2e, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0a,
	0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x41, 0x0a, 0x11, 0x74, 0x68,
	0x72, 0x65, 0x61, 0x74, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x79, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x15, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x54, 0x68, 0x72,
	0x65, 0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0f, 0x74, 0x68,
	0x72, 0x65, 0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x54, 0x79, 0x70, 0x65, 0x12, 0x37, 0x0a,
	0x0d, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x50, 0x6c, 0x61, 0x74,
	0x66, 0x6f, 0x72, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0c, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f,
	0x72, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x12, 0x69, 0x0a, 0x0d, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e,
	0x73, 0x65, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x44, 0x2e,
	0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x46, 0x65, 0x74, 0x63, 0x68, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74,
	0x4c, 0x69, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f,
	0x6e, 0x73, 0x65, 0x2e, 0x4c, 0x69, 0x73, 0x74, 0x55, 0x70, 0x64, 0x61, 0x74, 0x65, 0x52, 0x65,
	0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x54,
	0x79, 0x70, 0x65, 0x52, 0x0c, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x54, 0x79, 0x70,
	0x65, 0x12, 0x32, 0x0a, 0x09, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x18, 0x05,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x54, 0x68, 0x72, 0x65,
	0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x53, 0x65, 0x74, 0x52, 0x09, 0x61, 0x64, 0x64, 0x69,
	0x74, 0x69, 0x6f, 0x6e, 0x73, 0x12, 0x30, 0x0a, 0x08, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x61, 0x6c,
	0x73, 0x18, 0x06, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x14, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x54,
	0x68, 0x72, 0x65, 0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x53, 0x65, 0x74, 0x52, 0x08, 0x72,
	0x65, 0x6d, 0x6f, 0x76, 0x61, 0x6c, 0x73, 0x12, 0x28, 0x0a, 0x10, 0x6e, 0x65, 0x77, 0x5f, 0x63,
	0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x65, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x0c, 0x52, 0x0e, 0x6e, 0x65, 0x77, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x74,
	0x65, 0x12, 0x2a, 0x0a, 0x08, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x75, 0x6d, 0x18, 0x08, 0x20,
	0x01, 0x28, 0x0b, 0x32, 0x0e, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x43, 0x68, 0x65, 0x63, 0x6b,
	0x73, 0x75, 0x6d, 0x52, 0x08, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x73, 0x75, 0x6d, 0x22, 0x52, 0x0a,
	0x0c, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1d, 0x0a,
	0x19, 0x52, 0x45, 0x53, 0x50, 0x4f, 0x4e, 0x53, 0x45, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55,
	0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x12, 0x0a, 0x0e,
	0x50, 0x41, 0x52, 0x54, 0x49, 0x41, 0x4c, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x10, 0x01,
	0x12, 0x0f, 0x0a, 0x0b, 0x46, 0x55, 0x4c, 0x4c, 0x5f, 0x55, 0x50, 0x44, 0x41, 0x54, 0x45, 0x10,
	0x02, 0x22, 0x99, 0x01, 0x0a, 0x15, 0x46, 0x69, 0x6e, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x48, 0x61,
	0x73, 0x68, 0x65, 0x73, 0x52, 0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x12, 0x28, 0x0a, 0x06, 0x63,
	0x6c, 0x69, 0x65, 0x6e, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d, 0x61,
	0x69, 0x6e, 0x2e, 0x43, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x52, 0x06, 0x63,
	0x6c, 0x69, 0x65, 0x6e, 0x74, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f,
	0x73, 0x74, 0x61, 0x74, 0x65, 0x73, 0x18, 0x02, 0x20, 0x03, 0x28, 0x0c, 0x52, 0x0c, 0x63, 0x6c,
	0x69, 0x65, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x73, 0x12, 0x31, 0x0a, 0x0b, 0x74, 0x68,
	0x72, 0x65, 0x61, 0x74, 0x5f, 0x69, 0x6e, 0x66, 0x6f, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x10, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x49, 0x6e, 0x66,
	0x6f, 0x52, 0x0a, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x49, 0x6e, 0x66, 0x6f, 0x22, 0xe7, 0x01,
	0x0a, 0x16, 0x46, 0x69, 0x6e, 0x64, 0x46, 0x75, 0x6c, 0x6c, 0x48, 0x61, 0x73, 0x68, 0x65, 0x73,
	0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x2b, 0x0a, 0x07, 0x6d, 0x61, 0x74, 0x63,
	0x68, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6d, 0x61, 0x69, 0x6e,
	0x2e, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x4d, 0x61, 0x74, 0x63, 0x68, 0x52, 0x07, 0x6d, 0x61,
	0x74, 0x63, 0x68, 0x65, 0x73, 0x12, 0x4d, 0x0a, 0x15, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d,
	0x5f, 0x77, 0x61, 0x69, 0x74, 0x5f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x52,
	0x13, 0x6d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x57, 0x61, 0x69, 0x74, 0x44, 0x75, 0x72, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x12, 0x51, 0x0a, 0x17, 0x6e, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65,
	0x5f, 0x63, 0x61, 0x63, 0x68, 0x65, 0x5f, 0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x52, 0x15, 0x6e, 0x65, 0x67, 0x61, 0x74, 0x69, 0x76, 0x65, 0x43, 0x61, 0x63, 0x68, 0x65, 0x44,
	0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x50, 0x0a, 0x0a, 0x43, 0x6c, 0x69, 0x65, 0x6e,
	0x74, 0x49, 0x6e, 0x66, 0x6f, 0x12, 0x1b, 0x0a, 0x09, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f,
	0x69, 0x64, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x08, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74,
	0x49, 0x64, 0x12, 0x25, 0x0a, 0x0e, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x76, 0x65, 0x72,
	0x73, 0x69, 0x6f, 0x6e, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0d, 0x63, 0x6c, 0x69, 0x65,
	0x6e, 0x74, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x22, 0x22, 0x0a, 0x08, 0x43, 0x68, 0x65,
	0x63, 0x6b, 0x73, 0x75, 0x6d, 0x12, 0x16, 0x0a, 0x06, 0x73, 0x68, 0x61, 0x32, 0x35, 0x36, 0x18,
	0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x06, 0x73, 0x68, 0x61, 0x32, 0x35, 0x36, 0x22, 0x33, 0x0a,
	0x0b, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x12, 0x12, 0x0a, 0x04,
	0x68, 0x61, 0x73, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x04, 0x68, 0x61, 0x73, 0x68,
	0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x03, 0x75,
	0x72, 0x6c, 0x22, 0xab, 0x02, 0x0a, 0x0e, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x45, 0x6e, 0x74,
	0x72, 0x79, 0x53, 0x65, 0x74, 0x12, 0x40, 0x0a, 0x10, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73,
	0x73, 0x69, 0x6f, 0x6e, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32,
	0x15, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69,
	0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0f, 0x63, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73,
	0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x2e, 0x0a, 0x0a, 0x72, 0x61, 0x77, 0x5f, 0x68,
	0x61, 0x73, 0x68, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x0f, 0x2e, 0x6d, 0x61,
	0x69, 0x6e, 0x2e, 0x52, 0x61, 0x77, 0x48, 0x61, 0x73, 0x68, 0x65, 0x73, 0x52, 0x09, 0x72, 0x61,
	0x77, 0x48, 0x61, 0x73, 0x68, 0x65, 0x73, 0x12, 0x31, 0x0a, 0x0b, 0x72, 0x61, 0x77, 0x5f, 0x69,
	0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x10, 0x2e, 0x6d,
	0x61, 0x69, 0x6e, 0x2e, 0x52, 0x61, 0x77, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 0x52, 0x0a,
	0x72, 0x61, 0x77, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 0x12, 0x38, 0x0a, 0x0b, 0x72, 0x69,
	0x63, 0x65, 0x5f, 0x68, 0x61, 0x73, 0x68, 0x65, 0x73, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x17, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x52, 0x69, 0x63, 0x65, 0x44, 0x65, 0x6c, 0x74, 0x61,
	0x45, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x52, 0x0a, 0x72, 0x69, 0x63, 0x65, 0x48, 0x61,
	0x73, 0x68, 0x65, 0x73, 0x12, 0x3a, 0x0a, 0x0c, 0x72, 0x69, 0x63, 0x65, 0x5f, 0x69, 0x6e, 0x64,
	0x69, 0x63, 0x65, 0x73, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x17, 0x2e, 0x6d, 0x61, 0x69,
	0x6e, 0x2e, 0x52, 0x69, 0x63, 0x65, 0x44, 0x65, 0x6c, 0x74, 0x61, 0x45, 0x6e, 0x63, 0x6f, 0x64,
	0x69, 0x6e, 0x67, 0x52, 0x0b, 0x72, 0x69, 0x63, 0x65, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73,
	0x22, 0x26, 0x0a, 0x0a, 0x52, 0x61, 0x77, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 0x12, 0x18,
	0x0a, 0x07, 0x69, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x05, 0x52,
	0x07, 0x69, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73, 0x22, 0x4b, 0x0a, 0x09, 0x52, 0x61, 0x77, 0x48,
	0x61, 0x73, 0x68, 0x65, 0x73, 0x12, 0x1f, 0x0a, 0x0b, 0x70, 0x72, 0x65, 0x66, 0x69, 0x78, 0x5f,
	0x73, 0x69, 0x7a, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x70, 0x72, 0x65, 0x66,
	0x69, 0x78, 0x53, 0x69, 0x7a, 0x65, 0x12, 0x1d, 0x0a, 0x0a, 0x72, 0x61, 0x77, 0x5f, 0x68, 0x61,
	0x73, 0x68, 0x65, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x72, 0x61, 0x77, 0x48,
	0x61, 0x73, 0x68, 0x65, 0x73, 0x22, 0x9f, 0x01, 0x0a, 0x11, 0x52, 0x69, 0x63, 0x65, 0x44, 0x65,
	0x6c, 0x74, 0x61, 0x45, 0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x12, 0x1f, 0x0a, 0x0b, 0x66,
	0x69, 0x72, 0x73, 0x74, 0x5f, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x03,
	0x52, 0x0a, 0x66, 0x69, 0x72, 0x73, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x12, 0x25, 0x0a, 0x0e,
	0x72, 0x69, 0x63, 0x65, 0x5f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x65, 0x74, 0x65, 0x72, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x0d, 0x72, 0x69, 0x63, 0x65, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x65,
	0x74, 0x65, 0x72, 0x12, 0x1f, 0x0a, 0x0b, 0x6e, 0x75, 0x6d, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x69,
	0x65, 0x73, 0x18, 0x03, 0x20, 0x01, 0x28, 0x05, 0x52, 0x0a, 0x6e, 0x75, 0x6d, 0x45, 0x6e, 0x74,
	0x72, 0x69, 0x65, 0x73, 0x12, 0x21, 0x0a, 0x0c, 0x65, 0x6e, 0x63, 0x6f, 0x64, 0x65, 0x64, 0x5f,
	0x64, 0x61, 0x74, 0x61, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0b, 0x65, 0x6e, 0x63, 0x6f,
	0x64, 0x65, 0x64, 0x44, 0x61, 0x74, 0x61, 0x22, 0x91, 0x01, 0x0a, 0x13, 0x54, 0x68, 0x72, 0x65,
	0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x12,
	0x41, 0x0a, 0x07, 0x65, 0x6e, 0x74, 0x72, 0x69, 0x65, 0x73, 0x18, 0x01, 0x20, 0x03, 0x28, 0x0b,
	0x32, 0x27, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x2e, 0x4d, 0x65, 0x74, 0x61,
	0x64, 0x61, 0x74, 0x61, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x52, 0x07, 0x65, 0x6e, 0x74, 0x72, 0x69,
	0x65, 0x73, 0x1a, 0x37, 0x0a, 0x0d, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61, 0x45, 0x6e,
	0x74, 0x72, 0x79, 0x12, 0x10, 0x0a, 0x03, 0x6b, 0x65, 0x79, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c,
	0x52, 0x03, 0x6b, 0x65, 0x79, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0xc5, 0x01, 0x0a, 0x14,
	0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69,
	0x70, 0x74, 0x6f, 0x72, 0x12, 0x31, 0x0a, 0x0b, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x5f, 0x74,
	0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x10, 0x2e, 0x6d, 0x61, 0x69, 0x6e,
	0x2e, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x54, 0x79, 0x70, 0x65, 0x52, 0x0a, 0x74, 0x68, 0x72,
	0x65, 0x61, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x37, 0x0a, 0x0d, 0x70, 0x6c, 0x61, 0x74, 0x66,
	0x6f, 0x72, 0x6d, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12,
	0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x50, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x54, 0x79,
	0x70, 0x65, 0x52, 0x0c, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x54, 0x79, 0x70, 0x65,
	0x12, 0x41, 0x0a, 0x11, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x5f, 0x65, 0x6e, 0x74, 0x72, 0x79,
	0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x15, 0x2e, 0x6d, 0x61,
	0x69, 0x6e, 0x2e, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x54, 0x79,
	0x70, 0x65, 0x52, 0x0f, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x54,
	0x79, 0x70, 0x65, 0x22, 0x58, 0x0a, 0x17, 0x4c, 0x69, 0x73, 0x74, 0x54, 0x68, 0x72, 0x65, 0x61,
	0x74, 0x4c, 0x69, 0x73, 0x74, 0x73, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x12, 0x3d,
	0x0a, 0x0c, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x5f, 0x6c, 0x69, 0x73, 0x74, 0x73, 0x18, 0x01,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x1a, 0x2e, 0x6d, 0x61, 0x69, 0x6e, 0x2e, 0x54, 0x68, 0x72, 0x65,
	0x61, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x6f, 0x72,
	0x52, 0x0b, 0x74, 0x68, 0x72, 0x65, 0x61, 0x74, 0x4c, 0x69, 0x73, 0x74, 0x73, 0x2a, 0x8a, 0x01,
	0x0a, 0x0a, 0x54, 0x68, 0x72, 0x65, 0x61, 0x74, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1b, 0x0a, 0x17,
	0x54, 0x48, 0x52, 0x45, 0x41, 0x54, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50,
	0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x4d, 0x41, 0x4c,
	0x57, 0x41, 0x52, 0x45, 0x10, 0x01, 0x12, 0x16, 0x0a, 0x12, 0x53, 0x4f, 0x43, 0x49, 0x41, 0x4c,
	0x5f, 0x45, 0x4e, 0x47, 0x49, 0x4e, 0x45, 0x45, 0x52, 0x49, 0x4e, 0x47, 0x10, 0x02, 0x12, 0x15,
	0x0a, 0x11, 0x55, 0x4e, 0x57, 0x41, 0x4e, 0x54, 0x45, 0x44, 0x5f, 0x53, 0x4f, 0x46, 0x54, 0x57,
	0x41, 0x52, 0x45, 0x10, 0x03, 0x12, 0x23, 0x0a, 0x1f, 0x50, 0x4f, 0x54, 0x45, 0x4e, 0x54, 0x49,
	0x41, 0x4c, 0x4c, 0x59, 0x5f, 0x48, 0x41, 0x52, 0x4d, 0x46, 0x55, 0x4c, 0x5f, 0x41, 0x50, 0x50,
	0x4c, 0x49, 0x43, 0x41, 0x54, 0x49, 0x4f, 0x4e, 0x10, 0x04, 0x2a, 0x95, 0x01, 0x0a, 0x0c, 0x50,
	0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x12, 0x1d, 0x0a, 0x19, 0x50,
	0x4c, 0x41, 0x54, 0x46, 0x4f, 0x52, 0x4d, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53,
	0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x0b, 0x0a, 0x07, 0x57, 0x49,
	0x4e, 0x44, 0x4f, 0x57, 0x53, 0x10, 0x01, 0x12, 0x09, 0x0a, 0x05, 0x4c, 0x49, 0x4e, 0x55, 0x58,
	0x10, 0x02, 0x12, 0x0b, 0x0a, 0x07, 0x41, 0x4e, 0x44, 0x52, 0x4f, 0x49, 0x44, 0x10, 0x03, 0x12,
	0x07, 0x0a, 0x03, 0x4f, 0x53, 0x58, 0x10, 0x04, 0x12, 0x07, 0x0a, 0x03, 0x49, 0x4f, 0x53, 0x10,
	0x05, 0x12, 0x10, 0x0a, 0x0c, 0x41, 0x4e, 0x59, 0x5f, 0x50, 0x4c, 0x41, 0x54, 0x46, 0x4f, 0x52,
	0x4d, 0x10, 0x06, 0x12, 0x11, 0x0a, 0x0d, 0x41, 0x4c, 0x4c, 0x5f, 0x50, 0x4c, 0x41, 0x54, 0x46,
	0x4f, 0x52, 0x4d, 0x53, 0x10, 0x07, 0x12, 0x0a, 0x0a, 0x06, 0x43, 0x48, 0x52, 0x4f, 0x4d, 0x45,
	0x10, 0x08, 0x2a, 0x46, 0x0a, 0x0f, 0x43, 0x6f, 0x6d, 0x70, 0x72, 0x65, 0x73, 0x73, 0x69, 0x6f,
	0x6e, 0x54, 0x79, 0x70, 0x65, 0x12, 0x20, 0x0a, 0x1c, 0x43, 0x4f, 0x4d, 0x50, 0x52, 0x45, 0x53,
	0x53, 0x49, 0x4f, 0x4e, 0x5f, 0x54, 0x59, 0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43,
	0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00, 0x12, 0x07, 0x0a, 0x03, 0x52, 0x41, 0x57, 0x10, 0x01,
	0x12, 0x08, 0x0a, 0x04, 0x52, 0x49, 0x43, 0x45, 0x10, 0x02, 0x2a, 0x5b, 0x0a, 0x0f, 0x54, 0x68,
	0x72, 0x65, 0x61, 0x74, 0x45, 0x6e, 0x74, 0x72, 0x79, 0x54, 0x79, 0x70, 0x65, 0x12, 0x21, 0x0a,
	0x1d, 0x54, 0x48, 0x52, 0x45, 0x41, 0x54, 0x5f, 0x45, 0x4e, 0x54, 0x52, 0x59, 0x5f, 0x54, 0x59,
	0x50, 0x45, 0x5f, 0x55, 0x4e, 0x53, 0x50, 0x45, 0x43, 0x49, 0x46, 0x49, 0x45, 0x44, 0x10, 0x00,
	0x12, 0x07, 0x0a, 0x03, 0x55, 0x52, 0x4c, 0x10, 0x01, 0x12, 0x0e, 0x0a, 0x0a, 0x45, 0x58, 0x45,
	0x43, 0x55, 0x54, 0x41, 0x42, 0x4c, 0x45, 0x10, 0x02, 0x12, 0x0c, 0x0a, 0x08, 0x49, 0x50, 0x5f,
	0x52, 0x41, 0x4e, 0x47, 0x45, 0x10, 0x03, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	file_safebrowsing_proto_rawDescOnce sync.Once
	file_safebrowsing_proto_rawDescData = file_safebrowsing_proto_rawDesc
)

func file_safebrowsing_proto_rawDescGZIP() []byte {
	file_safebrowsing_proto_rawDescOnce.Do(func() {
		file_safebrowsing_proto_rawDescData = protoimpl.X.CompressGZIP(file_safebrowsing_proto_rawDescData)
	})
	return file_safebrowsing_proto_rawDescData
}

var file_safebrowsing_proto_enumTypes = make([]protoimpl.EnumInfo, 5)
var file_safebrowsing_proto_msgTypes = make([]protoimpl.MessageInfo, 22)
var file_safebrowsing_proto_goTypes = []interface{}{
	(ThreatType)(0),      // 0: main.ThreatType
	(PlatformType)(0),    // 1: main.PlatformType
	(CompressionType)(0), // 2: main.CompressionType
	(ThreatEntryType)(0), // 3: main.ThreatEntryType
	(FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType)(0), // 4: main.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType
	(*ThreatInfo)(nil),                                      // 5: main.ThreatInfo
	(*ThreatMatch)(nil),                                     // 6: main.ThreatMatch
	(*FindThreatMatchesRequest)(nil),                        // 7: main.FindThreatMatchesRequest
	(*FindThreatMatchesResponse)(nil),                       // 8: main.FindThreatMatchesResponse
	(*FetchThreatListUpdatesRequest)(nil),                   // 9: main.FetchThreatListUpdatesRequest
	(*FetchThreatListUpdatesResponse)(nil),                  // 10: main.FetchThreatListUpdatesResponse
	(*FindFullHashesRequest)(nil),                           // 11: main.FindFullHashesRequest
	(*FindFullHashesResponse)(nil),                          // 12: main.FindFullHashesResponse
	(*ClientInfo)(nil),                                      // 13: main.ClientInfo
	(*Checksum)(nil),                                        // 14: main.Checksum
	(*ThreatEntry)(nil),                                     // 15: main.ThreatEntry
	(*ThreatEntrySet)(nil),                                  // 16: main.ThreatEntrySet
	(*RawIndices)(nil),                                      // 17: main.RawIndices
	(*RawHashes)(nil),                                       // 18: main.RawHashes
	(*RiceDeltaEncoding)(nil),                               // 19: main.RiceDeltaEncoding
	(*ThreatEntryMetadata)(nil),                             // 20: main.ThreatEntryMetadata
	(*ThreatListDescriptor)(nil),                            // 21: main.ThreatListDescriptor
	(*ListThreatListsResponse)(nil),                         // 22: main.ListThreatListsResponse
	(*FetchThreatListUpdatesRequest_ListUpdateRequest)(nil), // 23: main.FetchThreatListUpdatesRequest.ListUpdateRequest
	(*FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints)(nil), // 24: main.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints
	(*FetchThreatListUpdatesResponse_ListUpdateResponse)(nil),           // 25: main.FetchThreatListUpdatesResponse.ListUpdateResponse
	(*ThreatEntryMetadata_MetadataEntry)(nil),                           // 26: main.ThreatEntryMetadata.MetadataEntry
	(*duration.Duration)(nil),                                           // 27: google.protobuf.Duration
}
var file_safebrowsing_proto_depIdxs = []int32{
	0,  // 0: main.ThreatInfo.threat_types:type_name -> main.ThreatType
	1,  // 1: main.ThreatInfo.platform_types:type_name -> main.PlatformType
	3,  // 2: main.ThreatInfo.threat_entry_types:type_name -> main.ThreatEntryType
	15, // 3: main.ThreatInfo.threat_entries:type_name -> main.ThreatEntry
	0,  // 4: main.ThreatMatch.threat_type:type_name -> main.ThreatType
	1,  // 5: main.ThreatMatch.platform_type:type_name -> main.PlatformType
	3,  // 6: main.ThreatMatch.threat_entry_type:type_name -> main.ThreatEntryType
	15, // 7: main.ThreatMatch.threat:type_name -> main.ThreatEntry
	20, // 8: main.ThreatMatch.threat_entry_metadata:type_name -> main.ThreatEntryMetadata
	27, // 9: main.ThreatMatch.cache_duration:type_name -> google.protobuf.Duration
	13, // 10: main.FindThreatMatchesRequest.client:type_name -> main.ClientInfo
	5,  // 11: main.FindThreatMatchesRequest.threat_info:type_name -> main.ThreatInfo
	6,  // 12: main.FindThreatMatchesResponse.matches:type_name -> main.ThreatMatch
	13, // 13: main.FetchThreatListUpdatesRequest.client:type_name -> main.ClientInfo
	23, // 14: main.FetchThreatListUpdatesRequest.list_update_requests:type_name -> main.FetchThreatListUpdatesRequest.ListUpdateRequest
	25, // 15: main.FetchThreatListUpdatesResponse.list_update_responses:type_name -> main.FetchThreatListUpdatesResponse.ListUpdateResponse
	27, // 16: main.FetchThreatListUpdatesResponse.minimum_wait_duration:type_name -> google.protobuf.Duration
	13, // 17: main.FindFullHashesRequest.client:type_name -> main.ClientInfo
	5,  // 18: main.FindFullHashesRequest.threat_info:type_name -> main.ThreatInfo
	6,  // 19: main.FindFullHashesResponse.matches:type_name -> main.ThreatMatch
	27, // 20: main.FindFullHashesResponse.minimum_wait_duration:type_name -> google.protobuf.Duration
	27, // 21: main.FindFullHashesResponse.negative_cache_duration:type_name -> google.protobuf.Duration
	2,  // 22: main.ThreatEntrySet.compression_type:type_name -> main.CompressionType
	18, // 23: main.ThreatEntrySet.raw_hashes:type_name -> main.RawHashes
	17, // 24: main.ThreatEntrySet.raw_indices:type_name -> main.RawIndices
	19, // 25: main.ThreatEntrySet.rice_hashes:type_name -> main.RiceDeltaEncoding
	19, // 26: main.ThreatEntrySet.rice_indices:type_name -> main.RiceDeltaEncoding
	26, // 27: main.ThreatEntryMetadata.entries:type_name -> main.ThreatEntryMetadata.MetadataEntry
	0,  // 28: main.ThreatListDescriptor.threat_type:type_name -> main.ThreatType
	1,  // 29: main.ThreatListDescriptor.platform_type:type_name -> main.PlatformType
	3,  // 30: main.ThreatListDescriptor.threat_entry_type:type_name -> main.ThreatEntryType
	21, // 31: main.ListThreatListsResponse.threat_lists:type_name -> main.ThreatListDescriptor
	0,  // 32: main.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_type:type_name -> main.ThreatType
	1,  // 33: main.FetchThreatListUpdatesRequest.ListUpdateRequest.platform_type:type_name -> main.PlatformType
	3,  // 34: main.FetchThreatListUpdatesRequest.ListUpdateRequest.threat_entry_type:type_name -> main.ThreatEntryType
	24, // 35: main.FetchThreatListUpdatesRequest.ListUpdateRequest.constraints:type_name -> main.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints
	2,  // 36: main.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints.supported_compressions:type_name -> main.CompressionType
	0,  // 37: main.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_type:type_name -> main.ThreatType
	3,  // 38: main.FetchThreatListUpdatesResponse.ListUpdateResponse.threat_entry_type:type_name -> main.ThreatEntryType
	1,  // 39: main.FetchThreatListUpdatesResponse.ListUpdateResponse.platform_type:type_name -> main.PlatformType
	4,  // 40: main.FetchThreatListUpdatesResponse.ListUpdateResponse.response_type:type_name -> main.FetchThreatListUpdatesResponse.ListUpdateResponse.ResponseType
	16, // 41: main.FetchThreatListUpdatesResponse.ListUpdateResponse.additions:type_name -> main.ThreatEntrySet
	16, // 42: main.FetchThreatListUpdatesResponse.ListUpdateResponse.removals:type_name -> main.ThreatEntrySet
	14, // 43: main.FetchThreatListUpdatesResponse.ListUpdateResponse.checksum:type_name -> main.Checksum
	44, // [44:44] is the sub-list for method output_type
	44, // [44:44] is the sub-list for method input_type
	44, // [44:44] is the sub-list for extension type_name
	44, // [44:44] is the sub-list for extension extendee
	0,  // [0:44] is the sub-list for field type_name
}

func init() { file_safebrowsing_proto_init() }
func file_safebrowsing_proto_init() {
	if File_safebrowsing_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {
		file_safebrowsing_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ThreatInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ThreatMatch); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FindThreatMatchesRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FindThreatMatchesResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FetchThreatListUpdatesRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FetchThreatListUpdatesResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FindFullHashesRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FindFullHashesResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ClientInfo); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*Checksum); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[10].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ThreatEntry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[11].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ThreatEntrySet); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[12].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RawIndices); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[13].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RawHashes); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[14].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*RiceDeltaEncoding); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[15].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ThreatEntryMetadata); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[16].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ThreatListDescriptor); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[17].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ListThreatListsResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[18].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FetchThreatListUpdatesRequest_ListUpdateRequest); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[19].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[20].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*FetchThreatListUpdatesResponse_ListUpdateResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		file_safebrowsing_proto_msgTypes[21].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ThreatEntryMetadata_MetadataEntry); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: file_safebrowsing_proto_rawDesc,
			NumEnums:      5,
			NumMessages:   22,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_safebrowsing_proto_goTypes,
		DependencyIndexes: file_safebrowsing_proto_depIdxs,
		EnumInfos:         file_safebrowsing_proto_enumTypes,
		MessageInfos:      file_safebrowsing_proto_msgTypes,
	}.Build()
	File_safebrowsing_proto = out.File
	file_safebrowsing_proto_rawDesc = nil
	file_safebrowsing_proto_goTypes = nil
	file_safebrowsing_proto_depIdxs = nil
}
