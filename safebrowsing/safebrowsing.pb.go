// Code generated by protoc-gen-go. DO NOT EDIT.
// source: safebrowsing.proto

/*
Package safebrowsing is a generated protocol buffer package.

It is generated from these files:
	safebrowsing.proto

It has these top-level messages:
	ThreatInfo
	ThreatMatch
	FindThreatMatchesRequest
	FindThreatMatchesResponse
	FetchThreatListUpdatesRequest
	FetchThreatListUpdatesResponse
	FindFullHashesRequest
	FindFullHashesResponse
	ThreatHit
	ClientInfo
	ChromeClientInfo
	Checksum
	ThreatEntry
	ThreatEntrySet
	RawIndices
	RawHashes
	RiceDeltaEncoding
	ThreatEntryMetadata
	ThreatListDescriptor
	ListThreatListsResponse
	Duration
*/
package safebrowsing

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Types of threats.
type ThreatType int32

const (
	// Unknown.
	ThreatType_THREAT_TYPE_UNSPECIFIED ThreatType = 0
	// Malware threat type.
	ThreatType_MALWARE_THREAT ThreatType = 1
	// Social engineering threat type.
	ThreatType_SOCIAL_ENGINEERING_PUBLIC ThreatType = 2
	// Unwanted software threat type.
	ThreatType_UNWANTED_SOFTWARE ThreatType = 3
	// Potentially harmful application threat type.
	ThreatType_POTENTIALLY_HARMFUL_APPLICATION ThreatType = 4
	// Social engineering threat type for internal use.
	ThreatType_SOCIAL_ENGINEERING ThreatType = 5
	// API abuse threat type.
	ThreatType_API_ABUSE ThreatType = 6
	// Malicious binary threat type.
	ThreatType_MALICIOUS_BINARY ThreatType = 7
	// Client side detection whitelist threat type.
	ThreatType_CSD_WHITELIST ThreatType = 8
	// Client side download detection whitelist threat type.
	ThreatType_CSD_DOWNLOAD_WHITELIST ThreatType = 9
	// Client incident threat type.
	ThreatType_CLIENT_INCIDENT ThreatType = 10
	// Patterns to be used for activating the subresource filter. Interstitial
	// will not be shown for patterns from this list.
	ThreatType_SUBRESOURCE_FILTER ThreatType = 13
	// Entities that are suspected to present a threat.
	ThreatType_SUSPICIOUS ThreatType = 14
	// Billing threat list. The internal proto's enum name is different
	ThreatType_BILLING ThreatType = 15
	// Safe list to ship hashes of known safe URL expressions.
	ThreatType_HIGH_CONFIDENCE_ALLOWLIST ThreatType = 16
)

var ThreatType_name = map[int32]string{
	0:  "THREAT_TYPE_UNSPECIFIED",
	1:  "MALWARE_THREAT",
	2:  "SOCIAL_ENGINEERING_PUBLIC",
	3:  "UNWANTED_SOFTWARE",
	4:  "POTENTIALLY_HARMFUL_APPLICATION",
	5:  "SOCIAL_ENGINEERING",
	6:  "API_ABUSE",
	7:  "MALICIOUS_BINARY",
	8:  "CSD_WHITELIST",
	9:  "CSD_DOWNLOAD_WHITELIST",
	10: "CLIENT_INCIDENT",
	13: "SUBRESOURCE_FILTER",
	14: "SUSPICIOUS",
	15: "BILLING",
	16: "HIGH_CONFIDENCE_ALLOWLIST",
}
var ThreatType_value = map[string]int32{
	"THREAT_TYPE_UNSPECIFIED":         0,
	"MALWARE_THREAT":                  1,
	"SOCIAL_ENGINEERING_PUBLIC":       2,
	"UNWANTED_SOFTWARE":               3,
	"POTENTIALLY_HARMFUL_APPLICATION": 4,
	"SOCIAL_ENGINEERING":              5,
	"API_ABUSE":                       6,
	"MALICIOUS_BINARY":                7,
	"CSD_WHITELIST":                   8,
	"CSD_DOWNLOAD_WHITELIST":          9,
	"CLIENT_INCIDENT":                 10,
	"SUBRESOURCE_FILTER":              13,
	"SUSPICIOUS":                      14,
	"BILLING":                         15,
	"HIGH_CONFIDENCE_ALLOWLIST":       16,
}

func (x ThreatType) Enum() *ThreatType {
	p := new(ThreatType)
	*p = x
	return p
}
func (x ThreatType) String() string {
	return proto.EnumName(ThreatType_name, int32(x))
}
func (x *ThreatType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ThreatType_value, data, "ThreatType")
	if err != nil {
		return err
	}
	*x = ThreatType(value)
	return nil
}
func (ThreatType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Types of platforms.
type PlatformType int32

const (
	// Unknown platform.
	PlatformType_PLATFORM_TYPE_UNSPECIFIED PlatformType = 0
	// Threat posed to Windows.
	PlatformType_WINDOWS_PLATFORM PlatformType = 1
	// Threat posed to Linux.
	PlatformType_LINUX_PLATFORM PlatformType = 2
	// Threat posed to Android.
	// This cannot be ANDROID because that symbol is defined for android builds
	// here: build/config/android/BUILD.gn line21.
	PlatformType_ANDROID_PLATFORM PlatformType = 3
	// Threat posed to OSX.
	PlatformType_OSX_PLATFORM PlatformType = 4
	// Threat posed to iOS.
	PlatformType_IOS_PLATFORM PlatformType = 5
	// Threat posed to at least one of the defined platforms.
	PlatformType_ANY_PLATFORM PlatformType = 6
	// Threat posed to all defined platforms.
	PlatformType_ALL_PLATFORMS PlatformType = 7
	// Threat posed to Chrome.
	PlatformType_CHROME_PLATFORM PlatformType = 8
)

var PlatformType_name = map[int32]string{
	0: "PLATFORM_TYPE_UNSPECIFIED",
	1: "WINDOWS_PLATFORM",
	2: "LINUX_PLATFORM",
	3: "ANDROID_PLATFORM",
	4: "OSX_PLATFORM",
	5: "IOS_PLATFORM",
	6: "ANY_PLATFORM",
	7: "ALL_PLATFORMS",
	8: "CHROME_PLATFORM",
}
var PlatformType_value = map[string]int32{
	"PLATFORM_TYPE_UNSPECIFIED": 0,
	"WINDOWS_PLATFORM":          1,
	"LINUX_PLATFORM":            2,
	"ANDROID_PLATFORM":          3,
	"OSX_PLATFORM":              4,
	"IOS_PLATFORM":              5,
	"ANY_PLATFORM":              6,
	"ALL_PLATFORMS":             7,
	"CHROME_PLATFORM":           8,
}

func (x PlatformType) Enum() *PlatformType {
	p := new(PlatformType)
	*p = x
	return p
}
func (x PlatformType) String() string {
	return proto.EnumName(PlatformType_name, int32(x))
}
func (x *PlatformType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(PlatformType_value, data, "PlatformType")
	if err != nil {
		return err
	}
	*x = PlatformType(value)
	return nil
}
func (PlatformType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// The ways in which threat entry sets can be compressed.
type CompressionType int32

const (
	// Unknown.
	CompressionType_COMPRESSION_TYPE_UNSPECIFIED CompressionType = 0
	// Raw, uncompressed data.
	CompressionType_RAW CompressionType = 1
	// Rice-Golomb encoded data.
	CompressionType_RICE CompressionType = 2
)

var CompressionType_name = map[int32]string{
	0: "COMPRESSION_TYPE_UNSPECIFIED",
	1: "RAW",
	2: "RICE",
}
var CompressionType_value = map[string]int32{
	"COMPRESSION_TYPE_UNSPECIFIED": 0,
	"RAW":  1,
	"RICE": 2,
}

func (x CompressionType) Enum() *CompressionType {
	p := new(CompressionType)
	*p = x
	return p
}
func (x CompressionType) String() string {
	return proto.EnumName(CompressionType_name, int32(x))
}
func (x *CompressionType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CompressionType_value, data, "CompressionType")
	if err != nil {
		return err
	}
	*x = CompressionType(value)
	return nil
}
func (CompressionType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Types of entries that pose threats. Threat lists are collections of entries
// of a single type.
type ThreatEntryType int32

const (
	// Unspecified.
	ThreatEntryType_THREAT_ENTRY_TYPE_UNSPECIFIED ThreatEntryType = 0
	// A host-suffix/path-prefix URL expression; for example, "foo.bar.com/baz/".
	ThreatEntryType_URL ThreatEntryType = 1
	// An executable program.
	ThreatEntryType_EXECUTABLE ThreatEntryType = 2
	// An IP range.
	ThreatEntryType_IP_RANGE ThreatEntryType = 3
	// Chrome extension.
	ThreatEntryType_CHROME_EXTENSION ThreatEntryType = 4
	// Filename.
	ThreatEntryType_FILENAME ThreatEntryType = 5
	// CERT.
	ThreatEntryType_CERT ThreatEntryType = 6
)

var ThreatEntryType_name = map[int32]string{
	0: "THREAT_ENTRY_TYPE_UNSPECIFIED",
	1: "URL",
	2: "EXECUTABLE",
	3: "IP_RANGE",
	4: "CHROME_EXTENSION",
	5: "FILENAME",
	6: "CERT",
}
var ThreatEntryType_value = map[string]int32{
	"THREAT_ENTRY_TYPE_UNSPECIFIED": 0,
	"URL":              1,
	"EXECUTABLE":       2,
	"IP_RANGE":         3,
	"CHROME_EXTENSION": 4,
	"FILENAME":         5,
	"CERT":             6,
}

func (x ThreatEntryType) Enum() *ThreatEntryType {
	p := new(ThreatEntryType)
	*p = x
	return p
}
func (x ThreatEntryType) String() string {
	return proto.EnumName(ThreatEntryType_name, int32(x))
}
func (x *ThreatEntryType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ThreatEntryType_value, data, "ThreatEntryType")
	if err != nil {
		return err
	}
	*x = ThreatEntryType(value)
	return nil
}
func (ThreatEntryType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// The type of response sent to the client.
type FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType int32

const (
	// Unknown.
	FetchThreatListUpdatesResponse_ListUpdateResponse_RESPONSE_TYPE_UNSPECIFIED FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType = 0
	// Partial updates are applied to the client's existing local database.
	FetchThreatListUpdatesResponse_ListUpdateResponse_PARTIAL_UPDATE FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType = 1
	// Full updates replace the client's entire local database. This means
	// that either the client was seriously out-of-date or the client is
	// believed to be corrupt.
	FetchThreatListUpdatesResponse_ListUpdateResponse_FULL_UPDATE FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType = 2
)

var FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_name = map[int32]string{
	0: "RESPONSE_TYPE_UNSPECIFIED",
	1: "PARTIAL_UPDATE",
	2: "FULL_UPDATE",
}
var FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_value = map[string]int32{
	"RESPONSE_TYPE_UNSPECIFIED": 0,
	"PARTIAL_UPDATE":            1,
	"FULL_UPDATE":               2,
}

func (x FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType) Enum() *FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType {
	p := new(FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType)
	*p = x
	return p
}
func (x FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType) String() string {
	return proto.EnumName(FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_name, int32(x))
}
func (x *FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_value, data, "FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType")
	if err != nil {
		return err
	}
	*x = FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType(value)
	return nil
}
func (FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{5, 0, 0}
}

// Types of resources reported by the client as part of a single hit.
type ThreatHit_ThreatSourceType int32

const (
	// Unknown.
	ThreatHit_THREAT_SOURCE_TYPE_UNSPECIFIED ThreatHit_ThreatSourceType = 0
	// The URL that matched the threat list (for which GetFullHash returned a
	// valid hash).
	ThreatHit_MATCHING_URL ThreatHit_ThreatSourceType = 1
	// The final top-level URL of the tab that the client was browsing when the
	// match occurred.
	ThreatHit_TAB_URL ThreatHit_ThreatSourceType = 2
	// A redirect URL that was fetched before hitting the final TAB_URL.
	ThreatHit_TAB_REDIRECT ThreatHit_ThreatSourceType = 3
)

var ThreatHit_ThreatSourceType_name = map[int32]string{
	0: "THREAT_SOURCE_TYPE_UNSPECIFIED",
	1: "MATCHING_URL",
	2: "TAB_URL",
	3: "TAB_REDIRECT",
}
var ThreatHit_ThreatSourceType_value = map[string]int32{
	"THREAT_SOURCE_TYPE_UNSPECIFIED": 0,
	"MATCHING_URL":                   1,
	"TAB_URL":                        2,
	"TAB_REDIRECT":                   3,
}

func (x ThreatHit_ThreatSourceType) Enum() *ThreatHit_ThreatSourceType {
	p := new(ThreatHit_ThreatSourceType)
	*p = x
	return p
}
func (x ThreatHit_ThreatSourceType) String() string {
	return proto.EnumName(ThreatHit_ThreatSourceType_name, int32(x))
}
func (x *ThreatHit_ThreatSourceType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ThreatHit_ThreatSourceType_value, data, "ThreatHit_ThreatSourceType")
	if err != nil {
		return err
	}
	*x = ThreatHit_ThreatSourceType(value)
	return nil
}
func (ThreatHit_ThreatSourceType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{8, 0}
}

// Safe Browsing reporting populations in Chrome.
type ChromeClientInfo_SafeBrowsingReportingPopulation int32

const (
	// Unspecified reporting verbosity.
	ChromeClientInfo_UNSPECIFIED ChromeClientInfo_SafeBrowsingReportingPopulation = 0
	// Client is opted out of reporting.
	ChromeClientInfo_OPT_OUT ChromeClientInfo_SafeBrowsingReportingPopulation = 1
	// Legacy extended reporting population.
	ChromeClientInfo_EXTENDED ChromeClientInfo_SafeBrowsingReportingPopulation = 2
	// Scout reporting population.
	ChromeClientInfo_SCOUT ChromeClientInfo_SafeBrowsingReportingPopulation = 3
)

var ChromeClientInfo_SafeBrowsingReportingPopulation_name = map[int32]string{
	0: "UNSPECIFIED",
	1: "OPT_OUT",
	2: "EXTENDED",
	3: "SCOUT",
}
var ChromeClientInfo_SafeBrowsingReportingPopulation_value = map[string]int32{
	"UNSPECIFIED": 0,
	"OPT_OUT":     1,
	"EXTENDED":    2,
	"SCOUT":       3,
}

func (x ChromeClientInfo_SafeBrowsingReportingPopulation) Enum() *ChromeClientInfo_SafeBrowsingReportingPopulation {
	p := new(ChromeClientInfo_SafeBrowsingReportingPopulation)
	*p = x
	return p
}
func (x ChromeClientInfo_SafeBrowsingReportingPopulation) String() string {
	return proto.EnumName(ChromeClientInfo_SafeBrowsingReportingPopulation_name, int32(x))
}
func (x *ChromeClientInfo_SafeBrowsingReportingPopulation) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ChromeClientInfo_SafeBrowsingReportingPopulation_value, data, "ChromeClientInfo_SafeBrowsingReportingPopulation")
	if err != nil {
		return err
	}
	*x = ChromeClientInfo_SafeBrowsingReportingPopulation(value)
	return nil
}
func (ChromeClientInfo_SafeBrowsingReportingPopulation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{10, 0}
}

type ThreatInfo struct {
	// The threat types to be checked.
	ThreatTypes []ThreatType `protobuf:"varint,1,rep,name=threat_types,json=threatTypes,enum=safebrowsing.ThreatType" json:"threat_types,omitempty"`
	// The platform types to be checked.
	PlatformTypes []PlatformType `protobuf:"varint,2,rep,name=platform_types,json=platformTypes,enum=safebrowsing.PlatformType" json:"platform_types,omitempty"`
	// The entry types to be checked.
	ThreatEntryTypes []ThreatEntryType `protobuf:"varint,4,rep,name=threat_entry_types,json=threatEntryTypes,enum=safebrowsing.ThreatEntryType" json:"threat_entry_types,omitempty"`
	// The threat entries to be checked.
	ThreatEntries    []*ThreatEntry `protobuf:"bytes,3,rep,name=threat_entries,json=threatEntries" json:"threat_entries,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *ThreatInfo) Reset()                    { *m = ThreatInfo{} }
func (m *ThreatInfo) String() string            { return proto.CompactTextString(m) }
func (*ThreatInfo) ProtoMessage()               {}
func (*ThreatInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ThreatInfo) GetThreatTypes() []ThreatType {
	if m != nil {
		return m.ThreatTypes
	}
	return nil
}

func (m *ThreatInfo) GetPlatformTypes() []PlatformType {
	if m != nil {
		return m.PlatformTypes
	}
	return nil
}

func (m *ThreatInfo) GetThreatEntryTypes() []ThreatEntryType {
	if m != nil {
		return m.ThreatEntryTypes
	}
	return nil
}

func (m *ThreatInfo) GetThreatEntries() []*ThreatEntry {
	if m != nil {
		return m.ThreatEntries
	}
	return nil
}

// A match when checking a threat entry in the Safe Browsing threat lists.
type ThreatMatch struct {
	// The threat type matching this threat.
	ThreatType *ThreatType `protobuf:"varint,1,opt,name=threat_type,json=threatType,enum=safebrowsing.ThreatType" json:"threat_type,omitempty"`
	// The platform type matching this threat.
	PlatformType *PlatformType `protobuf:"varint,2,opt,name=platform_type,json=platformType,enum=safebrowsing.PlatformType" json:"platform_type,omitempty"`
	// The threat entry type matching this threat.
	ThreatEntryType *ThreatEntryType `protobuf:"varint,6,opt,name=threat_entry_type,json=threatEntryType,enum=safebrowsing.ThreatEntryType" json:"threat_entry_type,omitempty"`
	// The threat matching this threat.
	Threat *ThreatEntry `protobuf:"bytes,3,opt,name=threat" json:"threat,omitempty"`
	// Optional metadata associated with this threat.
	ThreatEntryMetadata *ThreatEntryMetadata `protobuf:"bytes,4,opt,name=threat_entry_metadata,json=threatEntryMetadata" json:"threat_entry_metadata,omitempty"`
	// The cache lifetime for the returned match. Clients must not cache this
	// response for more than this duration to avoid false positives.
	CacheDuration    *Duration `protobuf:"bytes,5,opt,name=cache_duration,json=cacheDuration" json:"cache_duration,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *ThreatMatch) Reset()                    { *m = ThreatMatch{} }
func (m *ThreatMatch) String() string            { return proto.CompactTextString(m) }
func (*ThreatMatch) ProtoMessage()               {}
func (*ThreatMatch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ThreatMatch) GetThreatType() ThreatType {
	if m != nil && m.ThreatType != nil {
		return *m.ThreatType
	}
	return ThreatType_THREAT_TYPE_UNSPECIFIED
}

func (m *ThreatMatch) GetPlatformType() PlatformType {
	if m != nil && m.PlatformType != nil {
		return *m.PlatformType
	}
	return PlatformType_PLATFORM_TYPE_UNSPECIFIED
}

func (m *ThreatMatch) GetThreatEntryType() ThreatEntryType {
	if m != nil && m.ThreatEntryType != nil {
		return *m.ThreatEntryType
	}
	return ThreatEntryType_THREAT_ENTRY_TYPE_UNSPECIFIED
}

func (m *ThreatMatch) GetThreat() *ThreatEntry {
	if m != nil {
		return m.Threat
	}
	return nil
}

func (m *ThreatMatch) GetThreatEntryMetadata() *ThreatEntryMetadata {
	if m != nil {
		return m.ThreatEntryMetadata
	}
	return nil
}

func (m *ThreatMatch) GetCacheDuration() *Duration {
	if m != nil {
		return m.CacheDuration
	}
	return nil
}

// Request to check entries against lists.
type FindThreatMatchesRequest struct {
	// The client metadata.
	Client *ClientInfo `protobuf:"bytes,1,opt,name=client" json:"client,omitempty"`
	// The lists and entries to be checked for matches.
	ThreatInfo       *ThreatInfo `protobuf:"bytes,2,opt,name=threat_info,json=threatInfo" json:"threat_info,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *FindThreatMatchesRequest) Reset()                    { *m = FindThreatMatchesRequest{} }
func (m *FindThreatMatchesRequest) String() string            { return proto.CompactTextString(m) }
func (*FindThreatMatchesRequest) ProtoMessage()               {}
func (*FindThreatMatchesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *FindThreatMatchesRequest) GetClient() *ClientInfo {
	if m != nil {
		return m.Client
	}
	return nil
}

func (m *FindThreatMatchesRequest) GetThreatInfo() *ThreatInfo {
	if m != nil {
		return m.ThreatInfo
	}
	return nil
}

// Response type for requests to find threat matches.
type FindThreatMatchesResponse struct {
	// The threat list matches.
	Matches          []*ThreatMatch `protobuf:"bytes,1,rep,name=matches" json:"matches,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *FindThreatMatchesResponse) Reset()                    { *m = FindThreatMatchesResponse{} }
func (m *FindThreatMatchesResponse) String() string            { return proto.CompactTextString(m) }
func (*FindThreatMatchesResponse) ProtoMessage()               {}
func (*FindThreatMatchesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *FindThreatMatchesResponse) GetMatches() []*ThreatMatch {
	if m != nil {
		return m.Matches
	}
	return nil
}

// Describes a Safe Browsing API update request. Clients can request updates for
// multiple lists in a single request.
type FetchThreatListUpdatesRequest struct {
	// The client metadata.
	Client *ClientInfo `protobuf:"bytes,1,opt,name=client" json:"client,omitempty"`
	// The requested threat list updates.
	ListUpdateRequests []*FetchThreatListUpdatesRequest_ListUpdateRequest `protobuf:"bytes,3,rep,name=list_update_requests,json=listUpdateRequests" json:"list_update_requests,omitempty"`
	// Chrome-specific client information.
	ChromeClientInfo *ChromeClientInfo `protobuf:"bytes,4,opt,name=chrome_client_info,json=chromeClientInfo" json:"chrome_client_info,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *FetchThreatListUpdatesRequest) Reset()                    { *m = FetchThreatListUpdatesRequest{} }
func (m *FetchThreatListUpdatesRequest) String() string            { return proto.CompactTextString(m) }
func (*FetchThreatListUpdatesRequest) ProtoMessage()               {}
func (*FetchThreatListUpdatesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *FetchThreatListUpdatesRequest) GetClient() *ClientInfo {
	if m != nil {
		return m.Client
	}
	return nil
}

func (m *FetchThreatListUpdatesRequest) GetListUpdateRequests() []*FetchThreatListUpdatesRequest_ListUpdateRequest {
	if m != nil {
		return m.ListUpdateRequests
	}
	return nil
}

func (m *FetchThreatListUpdatesRequest) GetChromeClientInfo() *ChromeClientInfo {
	if m != nil {
		return m.ChromeClientInfo
	}
	return nil
}

// A single list update request.
type FetchThreatListUpdatesRequest_ListUpdateRequest struct {
	// The type of threat posed by entries present in the list.
	ThreatType *ThreatType `protobuf:"varint,1,opt,name=threat_type,json=threatType,enum=safebrowsing.ThreatType" json:"threat_type,omitempty"`
	// The type of platform at risk by entries present in the list.
	PlatformType *PlatformType `protobuf:"varint,2,opt,name=platform_type,json=platformType,enum=safebrowsing.PlatformType" json:"platform_type,omitempty"`
	// The types of entries present in the list.
	ThreatEntryType *ThreatEntryType `protobuf:"varint,5,opt,name=threat_entry_type,json=threatEntryType,enum=safebrowsing.ThreatEntryType" json:"threat_entry_type,omitempty"`
	// The current state of the client for the requested list (the encrypted
	// ClientState that was sent to the client from the previous update
	// request).
	State []byte `protobuf:"bytes,3,opt,name=state" json:"state,omitempty"`
	// The constraints associated with this request.
	Constraints      *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints `protobuf:"bytes,4,opt,name=constraints" json:"constraints,omitempty"`
	XXX_unrecognized []byte                                                       `json:"-"`
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest) Reset() {
	*m = FetchThreatListUpdatesRequest_ListUpdateRequest{}
}
func (m *FetchThreatListUpdatesRequest_ListUpdateRequest) String() string {
	return proto.CompactTextString(m)
}
func (*FetchThreatListUpdatesRequest_ListUpdateRequest) ProtoMessage() {}
func (*FetchThreatListUpdatesRequest_ListUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0}
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest) GetThreatType() ThreatType {
	if m != nil && m.ThreatType != nil {
		return *m.ThreatType
	}
	return ThreatType_THREAT_TYPE_UNSPECIFIED
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest) GetPlatformType() PlatformType {
	if m != nil && m.PlatformType != nil {
		return *m.PlatformType
	}
	return PlatformType_PLATFORM_TYPE_UNSPECIFIED
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest) GetThreatEntryType() ThreatEntryType {
	if m != nil && m.ThreatEntryType != nil {
		return *m.ThreatEntryType
	}
	return ThreatEntryType_THREAT_ENTRY_TYPE_UNSPECIFIED
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest) GetConstraints() *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints {
	if m != nil {
		return m.Constraints
	}
	return nil
}

// The constraints for this update.
type FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints struct {
	// The maximum size in number of entries. The update will not contain more
	// entries than this value.  This should be a power of 2 between 2**10 and
	// 2**20.  If zero, no update size limit is set.
	MaxUpdateEntries *int32 `protobuf:"varint,1,opt,name=max_update_entries,json=maxUpdateEntries" json:"max_update_entries,omitempty"`
	// Sets the maxmimum number of entries that the client is willing to have
	// in the local database. This should be a power of 2 between 2**10 and
	// 2**20. If zero, no database size limit is set.
	MaxDatabaseEntries *int32 `protobuf:"varint,2,opt,name=max_database_entries,json=maxDatabaseEntries" json:"max_database_entries,omitempty"`
	// Requests the list for a specific geographic location. If not set the
	// server may pick that value based on the user's IP address. Expects ISO
	// 3166-1 alpha-2 format.
	Region *string `protobuf:"bytes,3,opt,name=region" json:"region,omitempty"`
	// The compression types supported by the client.
	SupportedCompressions []CompressionType `protobuf:"varint,4,rep,name=supported_compressions,json=supportedCompressions,enum=safebrowsing.CompressionType" json:"supported_compressions,omitempty"`
	XXX_unrecognized      []byte            `json:"-"`
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) Reset() {
	*m = FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints{}
}
func (m *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) String() string {
	return proto.CompactTextString(m)
}
func (*FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) ProtoMessage() {}
func (*FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0, 0}
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) GetMaxUpdateEntries() int32 {
	if m != nil && m.MaxUpdateEntries != nil {
		return *m.MaxUpdateEntries
	}
	return 0
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) GetMaxDatabaseEntries() int32 {
	if m != nil && m.MaxDatabaseEntries != nil {
		return *m.MaxDatabaseEntries
	}
	return 0
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) GetRegion() string {
	if m != nil && m.Region != nil {
		return *m.Region
	}
	return ""
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) GetSupportedCompressions() []CompressionType {
	if m != nil {
		return m.SupportedCompressions
	}
	return nil
}

// Response type for threat list update requests.
type FetchThreatListUpdatesResponse struct {
	// The list updates requested by the clients.
	ListUpdateResponses []*FetchThreatListUpdatesResponse_ListUpdateResponse `protobuf:"bytes,1,rep,name=list_update_responses,json=listUpdateResponses" json:"list_update_responses,omitempty"`
	// The minimum duration the client must wait before issuing any update
	// request. If this field is not set clients may update as soon as they want.
	MinimumWaitDuration *Duration `protobuf:"bytes,2,opt,name=minimum_wait_duration,json=minimumWaitDuration" json:"minimum_wait_duration,omitempty"`
	XXX_unrecognized    []byte    `json:"-"`
}

func (m *FetchThreatListUpdatesResponse) Reset()                    { *m = FetchThreatListUpdatesResponse{} }
func (m *FetchThreatListUpdatesResponse) String() string            { return proto.CompactTextString(m) }
func (*FetchThreatListUpdatesResponse) ProtoMessage()               {}
func (*FetchThreatListUpdatesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *FetchThreatListUpdatesResponse) GetListUpdateResponses() []*FetchThreatListUpdatesResponse_ListUpdateResponse {
	if m != nil {
		return m.ListUpdateResponses
	}
	return nil
}

func (m *FetchThreatListUpdatesResponse) GetMinimumWaitDuration() *Duration {
	if m != nil {
		return m.MinimumWaitDuration
	}
	return nil
}

// An update to an individual list.
type FetchThreatListUpdatesResponse_ListUpdateResponse struct {
	// The threat type for which data is returned.
	ThreatType *ThreatType `protobuf:"varint,1,opt,name=threat_type,json=threatType,enum=safebrowsing.ThreatType" json:"threat_type,omitempty"`
	// The format of the threats.
	ThreatEntryType *ThreatEntryType `protobuf:"varint,2,opt,name=threat_entry_type,json=threatEntryType,enum=safebrowsing.ThreatEntryType" json:"threat_entry_type,omitempty"`
	// The platform type for which data is returned.
	PlatformType *PlatformType `protobuf:"varint,3,opt,name=platform_type,json=platformType,enum=safebrowsing.PlatformType" json:"platform_type,omitempty"`
	// The type of response. This may indicate that an action is required by the
	// client when the response is received.
	ResponseType *FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType `protobuf:"varint,4,opt,name=response_type,json=responseType,enum=safebrowsing.FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType" json:"response_type,omitempty"`
	// A set of entries to add to a local threat type's list. Repeated to allow
	// for a combination of compressed and raw data to be sent in a single
	// response.
	Additions []*ThreatEntrySet `protobuf:"bytes,5,rep,name=additions" json:"additions,omitempty"`
	// A set of entries to remove from a local threat type's list. In practice,
	// this field is empty or contains exactly one ThreatEntrySet.
	Removals []*ThreatEntrySet `protobuf:"bytes,6,rep,name=removals" json:"removals,omitempty"`
	// The new client state, in encrypted format. Opaque to clients.
	NewClientState []byte `protobuf:"bytes,7,opt,name=new_client_state,json=newClientState" json:"new_client_state,omitempty"`
	// The expected SHA256 hash of the client state; that is, of the sorted list
	// of all hashes present in the database after applying the provided update.
	// If the client state doesn't match the expected state, the client must
	// disregard this update and retry later.
	Checksum         *Checksum `protobuf:"bytes,8,opt,name=checksum" json:"checksum,omitempty"`
	XXX_unrecognized []byte    `json:"-"`
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) Reset() {
	*m = FetchThreatListUpdatesResponse_ListUpdateResponse{}
}
func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) String() string {
	return proto.CompactTextString(m)
}
func (*FetchThreatListUpdatesResponse_ListUpdateResponse) ProtoMessage() {}
func (*FetchThreatListUpdatesResponse_ListUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{5, 0}
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) GetThreatType() ThreatType {
	if m != nil && m.ThreatType != nil {
		return *m.ThreatType
	}
	return ThreatType_THREAT_TYPE_UNSPECIFIED
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) GetThreatEntryType() ThreatEntryType {
	if m != nil && m.ThreatEntryType != nil {
		return *m.ThreatEntryType
	}
	return ThreatEntryType_THREAT_ENTRY_TYPE_UNSPECIFIED
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) GetPlatformType() PlatformType {
	if m != nil && m.PlatformType != nil {
		return *m.PlatformType
	}
	return PlatformType_PLATFORM_TYPE_UNSPECIFIED
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) GetResponseType() FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType {
	if m != nil && m.ResponseType != nil {
		return *m.ResponseType
	}
	return FetchThreatListUpdatesResponse_ListUpdateResponse_RESPONSE_TYPE_UNSPECIFIED
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) GetAdditions() []*ThreatEntrySet {
	if m != nil {
		return m.Additions
	}
	return nil
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) GetRemovals() []*ThreatEntrySet {
	if m != nil {
		return m.Removals
	}
	return nil
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) GetNewClientState() []byte {
	if m != nil {
		return m.NewClientState
	}
	return nil
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) GetChecksum() *Checksum {
	if m != nil {
		return m.Checksum
	}
	return nil
}

// Request to return full hashes matched by the provided hash prefixes.
type FindFullHashesRequest struct {
	// The client metadata.
	Client *ClientInfo `protobuf:"bytes,1,opt,name=client" json:"client,omitempty"`
	// The current client states for each of the client's local threat lists.
	ClientStates [][]byte `protobuf:"bytes,2,rep,name=client_states,json=clientStates" json:"client_states,omitempty"`
	// The lists and hashes to be checked.
	ThreatInfo       *ThreatInfo `protobuf:"bytes,3,opt,name=threat_info,json=threatInfo" json:"threat_info,omitempty"`
	XXX_unrecognized []byte      `json:"-"`
}

func (m *FindFullHashesRequest) Reset()                    { *m = FindFullHashesRequest{} }
func (m *FindFullHashesRequest) String() string            { return proto.CompactTextString(m) }
func (*FindFullHashesRequest) ProtoMessage()               {}
func (*FindFullHashesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *FindFullHashesRequest) GetClient() *ClientInfo {
	if m != nil {
		return m.Client
	}
	return nil
}

func (m *FindFullHashesRequest) GetClientStates() [][]byte {
	if m != nil {
		return m.ClientStates
	}
	return nil
}

func (m *FindFullHashesRequest) GetThreatInfo() *ThreatInfo {
	if m != nil {
		return m.ThreatInfo
	}
	return nil
}

// Response type for requests to find full hashes.
type FindFullHashesResponse struct {
	// The full hashes that matched the requested prefixes.
	Matches []*ThreatMatch `protobuf:"bytes,1,rep,name=matches" json:"matches,omitempty"`
	// The minimum duration the client must wait before issuing any find hashes
	// request. If this field is not set, clients can issue a request as soon as
	// they want.
	MinimumWaitDuration *Duration `protobuf:"bytes,2,opt,name=minimum_wait_duration,json=minimumWaitDuration" json:"minimum_wait_duration,omitempty"`
	// For requested entities that did not match the threat list, how long to
	// cache the response.
	NegativeCacheDuration *Duration `protobuf:"bytes,3,opt,name=negative_cache_duration,json=negativeCacheDuration" json:"negative_cache_duration,omitempty"`
	XXX_unrecognized      []byte    `json:"-"`
}

func (m *FindFullHashesResponse) Reset()                    { *m = FindFullHashesResponse{} }
func (m *FindFullHashesResponse) String() string            { return proto.CompactTextString(m) }
func (*FindFullHashesResponse) ProtoMessage()               {}
func (*FindFullHashesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *FindFullHashesResponse) GetMatches() []*ThreatMatch {
	if m != nil {
		return m.Matches
	}
	return nil
}

func (m *FindFullHashesResponse) GetMinimumWaitDuration() *Duration {
	if m != nil {
		return m.MinimumWaitDuration
	}
	return nil
}

func (m *FindFullHashesResponse) GetNegativeCacheDuration() *Duration {
	if m != nil {
		return m.NegativeCacheDuration
	}
	return nil
}

// A hit comprised of multiple resources; one is the threat list entry that was
// encountered by the client, while others give context as to how the client
// arrived at the unsafe entry.
type ThreatHit struct {
	// The threat type reported.
	ThreatType *ThreatType `protobuf:"varint,1,opt,name=threat_type,json=threatType,enum=safebrowsing.ThreatType" json:"threat_type,omitempty"`
	// The platform type reported.
	PlatformType *PlatformType `protobuf:"varint,2,opt,name=platform_type,json=platformType,enum=safebrowsing.PlatformType" json:"platform_type,omitempty"`
	// The threat entry responsible for the hit. Full hash should be reported for
	// hash-based hits.
	Entry *ThreatEntry `protobuf:"bytes,3,opt,name=entry" json:"entry,omitempty"`
	// The resources related to the threat hit.
	Resources        []*ThreatHit_ThreatSource `protobuf:"bytes,4,rep,name=resources" json:"resources,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *ThreatHit) Reset()                    { *m = ThreatHit{} }
func (m *ThreatHit) String() string            { return proto.CompactTextString(m) }
func (*ThreatHit) ProtoMessage()               {}
func (*ThreatHit) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ThreatHit) GetThreatType() ThreatType {
	if m != nil && m.ThreatType != nil {
		return *m.ThreatType
	}
	return ThreatType_THREAT_TYPE_UNSPECIFIED
}

func (m *ThreatHit) GetPlatformType() PlatformType {
	if m != nil && m.PlatformType != nil {
		return *m.PlatformType
	}
	return PlatformType_PLATFORM_TYPE_UNSPECIFIED
}

func (m *ThreatHit) GetEntry() *ThreatEntry {
	if m != nil {
		return m.Entry
	}
	return nil
}

func (m *ThreatHit) GetResources() []*ThreatHit_ThreatSource {
	if m != nil {
		return m.Resources
	}
	return nil
}

// A single resource related to a threat hit.
type ThreatHit_ThreatSource struct {
	// The URL of the resource.
	Url *string `protobuf:"bytes,1,opt,name=url" json:"url,omitempty"`
	// The type of source reported.
	Type *ThreatHit_ThreatSourceType `protobuf:"varint,2,opt,name=type,enum=safebrowsing.ThreatHit_ThreatSourceType" json:"type,omitempty"`
	// The remote IP of the resource in ASCII format. Either IPv4 or IPv6.
	RemoteIp *string `protobuf:"bytes,3,opt,name=remote_ip,json=remoteIp" json:"remote_ip,omitempty"`
	// Referrer of the resource. Only set if the referrer is available.
	Referrer         *string `protobuf:"bytes,4,opt,name=referrer" json:"referrer,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ThreatHit_ThreatSource) Reset()                    { *m = ThreatHit_ThreatSource{} }
func (m *ThreatHit_ThreatSource) String() string            { return proto.CompactTextString(m) }
func (*ThreatHit_ThreatSource) ProtoMessage()               {}
func (*ThreatHit_ThreatSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8, 0} }

func (m *ThreatHit_ThreatSource) GetUrl() string {
	if m != nil && m.Url != nil {
		return *m.Url
	}
	return ""
}

func (m *ThreatHit_ThreatSource) GetType() ThreatHit_ThreatSourceType {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return ThreatHit_THREAT_SOURCE_TYPE_UNSPECIFIED
}

func (m *ThreatHit_ThreatSource) GetRemoteIp() string {
	if m != nil && m.RemoteIp != nil {
		return *m.RemoteIp
	}
	return ""
}

func (m *ThreatHit_ThreatSource) GetReferrer() string {
	if m != nil && m.Referrer != nil {
		return *m.Referrer
	}
	return ""
}

// The client metadata associated with Safe Browsing API requests.
type ClientInfo struct {
	// A client ID that (hopefully) uniquely identifies the client implementation
	// of the Safe Browsing API.
	ClientId *string `protobuf:"bytes,1,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
	// The version of the client implementation.
	ClientVersion    *string `protobuf:"bytes,2,opt,name=client_version,json=clientVersion" json:"client_version,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ClientInfo) Reset()                    { *m = ClientInfo{} }
func (m *ClientInfo) String() string            { return proto.CompactTextString(m) }
func (*ClientInfo) ProtoMessage()               {}
func (*ClientInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ClientInfo) GetClientId() string {
	if m != nil && m.ClientId != nil {
		return *m.ClientId
	}
	return ""
}

func (m *ClientInfo) GetClientVersion() string {
	if m != nil && m.ClientVersion != nil {
		return *m.ClientVersion
	}
	return ""
}

// The client metadata associated with Safe Browsing API requests specific to
// users of Chrome.
type ChromeClientInfo struct {
	// The reporting population of the user.
	ReportingPopulation *ChromeClientInfo_SafeBrowsingReportingPopulation `protobuf:"varint,1,opt,name=reporting_population,json=reportingPopulation,enum=safebrowsing.ChromeClientInfo_SafeBrowsingReportingPopulation" json:"reporting_population,omitempty"`
	XXX_unrecognized    []byte                                            `json:"-"`
}

func (m *ChromeClientInfo) Reset()                    { *m = ChromeClientInfo{} }
func (m *ChromeClientInfo) String() string            { return proto.CompactTextString(m) }
func (*ChromeClientInfo) ProtoMessage()               {}
func (*ChromeClientInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ChromeClientInfo) GetReportingPopulation() ChromeClientInfo_SafeBrowsingReportingPopulation {
	if m != nil && m.ReportingPopulation != nil {
		return *m.ReportingPopulation
	}
	return ChromeClientInfo_UNSPECIFIED
}

// The expected state of a client's local database.
type Checksum struct {
	// The SHA256 hash of the client state; that is, of the sorted list of all
	// hashes present in the database.
	Sha256           []byte `protobuf:"bytes,1,opt,name=sha256" json:"sha256,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Checksum) Reset()                    { *m = Checksum{} }
func (m *Checksum) String() string            { return proto.CompactTextString(m) }
func (*Checksum) ProtoMessage()               {}
func (*Checksum) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Checksum) GetSha256() []byte {
	if m != nil {
		return m.Sha256
	}
	return nil
}

// An individual threat; for example, a malicious URL or its hash
// representation. Only one of these fields should be set.
type ThreatEntry struct {
	// A variable-length SHA256 hash with size between 4 and 32 bytes inclusive.
	Hash []byte `protobuf:"bytes,1,opt,name=hash" json:"hash,omitempty"`
	// A URL.
	Url              *string `protobuf:"bytes,2,opt,name=url" json:"url,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ThreatEntry) Reset()                    { *m = ThreatEntry{} }
func (m *ThreatEntry) String() string            { return proto.CompactTextString(m) }
func (*ThreatEntry) ProtoMessage()               {}
func (*ThreatEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ThreatEntry) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *ThreatEntry) GetUrl() string {
	if m != nil && m.Url != nil {
		return *m.Url
	}
	return ""
}

// A set of threats that should be added or removed from a client's local
// database.
type ThreatEntrySet struct {
	// The compression type for the entries in this set.
	CompressionType *CompressionType `protobuf:"varint,1,opt,name=compression_type,json=compressionType,enum=safebrowsing.CompressionType" json:"compression_type,omitempty"`
	// At most one of the following fields should be set.
	// The raw SHA256-formatted entries.
	RawHashes *RawHashes `protobuf:"bytes,2,opt,name=raw_hashes,json=rawHashes" json:"raw_hashes,omitempty"`
	// The raw removal indices for a local list.
	RawIndices *RawIndices `protobuf:"bytes,3,opt,name=raw_indices,json=rawIndices" json:"raw_indices,omitempty"`
	// The encoded 4-byte prefixes of SHA256-formatted entries, using a
	// Golomb-Rice encoding.
	RiceHashes *RiceDeltaEncoding `protobuf:"bytes,4,opt,name=rice_hashes,json=riceHashes" json:"rice_hashes,omitempty"`
	// The encoded local, lexicographically-sorted list indices, using a
	// Golomb-Rice encoding. Used for sending compressed removal indicies.
	RiceIndices      *RiceDeltaEncoding `protobuf:"bytes,5,opt,name=rice_indices,json=riceIndices" json:"rice_indices,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *ThreatEntrySet) Reset()                    { *m = ThreatEntrySet{} }
func (m *ThreatEntrySet) String() string            { return proto.CompactTextString(m) }
func (*ThreatEntrySet) ProtoMessage()               {}
func (*ThreatEntrySet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ThreatEntrySet) GetCompressionType() CompressionType {
	if m != nil && m.CompressionType != nil {
		return *m.CompressionType
	}
	return CompressionType_COMPRESSION_TYPE_UNSPECIFIED
}

func (m *ThreatEntrySet) GetRawHashes() *RawHashes {
	if m != nil {
		return m.RawHashes
	}
	return nil
}

func (m *ThreatEntrySet) GetRawIndices() *RawIndices {
	if m != nil {
		return m.RawIndices
	}
	return nil
}

func (m *ThreatEntrySet) GetRiceHashes() *RiceDeltaEncoding {
	if m != nil {
		return m.RiceHashes
	}
	return nil
}

func (m *ThreatEntrySet) GetRiceIndices() *RiceDeltaEncoding {
	if m != nil {
		return m.RiceIndices
	}
	return nil
}

// A set of raw indicies to remove from a local list.
type RawIndices struct {
	// The indicies to remove from a lexicographically-sorted local list.
	Indices          []int32 `protobuf:"varint,1,rep,name=indices" json:"indices,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RawIndices) Reset()                    { *m = RawIndices{} }
func (m *RawIndices) String() string            { return proto.CompactTextString(m) }
func (*RawIndices) ProtoMessage()               {}
func (*RawIndices) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *RawIndices) GetIndices() []int32 {
	if m != nil {
		return m.Indices
	}
	return nil
}

// The uncompressed threat entries in hash format of a particular prefix length.
// Hashes can be anywhere from 4 to 32 bytes in size. A large majority are 4
// bytes, but some hashes are lengthened if they collide with the hash of a
// popular URL.
//
// Used for sending ThreatEntrySet to clients that do not support compression,
// or when sending non-4-byte hashes to clients that do support compression.
type RawHashes struct {
	// The number of bytes for each prefix encoded below.  This field can be
	// anywhere from 4 (shortest prefix) to 32 (full SHA256 hash).
	PrefixSize *int32 `protobuf:"varint,1,opt,name=prefix_size,json=prefixSize" json:"prefix_size,omitempty"`
	// The hashes, all concatenated into one long string.  Each hash has a prefix
	// size of |prefix_size| above. Hashes are sorted in lexicographic order.
	RawHashes        []byte `protobuf:"bytes,2,opt,name=raw_hashes,json=rawHashes" json:"raw_hashes,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RawHashes) Reset()                    { *m = RawHashes{} }
func (m *RawHashes) String() string            { return proto.CompactTextString(m) }
func (*RawHashes) ProtoMessage()               {}
func (*RawHashes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *RawHashes) GetPrefixSize() int32 {
	if m != nil && m.PrefixSize != nil {
		return *m.PrefixSize
	}
	return 0
}

func (m *RawHashes) GetRawHashes() []byte {
	if m != nil {
		return m.RawHashes
	}
	return nil
}

// The Rice-Golomb encoded data. Used for sending compressed 4-byte hashes or
// compressed removal indices.
type RiceDeltaEncoding struct {
	// The offset of the first entry in the encoded data, or, if only a single
	// integer was encoded, that single integer's value.
	FirstValue *int64 `protobuf:"varint,1,opt,name=first_value,json=firstValue" json:"first_value,omitempty"`
	// The Golomb-Rice parameter which is a number between 2 and 28. This field
	// is missing (that is, zero) if num_entries is zero.
	RiceParameter *int32 `protobuf:"varint,2,opt,name=rice_parameter,json=riceParameter" json:"rice_parameter,omitempty"`
	// The number of entries that are delta encoded in the encoded data. If only a
	// single integer was encoded, this will be zero and the single value will be
	// stored in first_value.
	NumEntries *int32 `protobuf:"varint,3,opt,name=num_entries,json=numEntries" json:"num_entries,omitempty"`
	// The encoded deltas that are encoded using the Golomb-Rice coder.
	EncodedData      []byte `protobuf:"bytes,4,opt,name=encoded_data,json=encodedData" json:"encoded_data,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *RiceDeltaEncoding) Reset()                    { *m = RiceDeltaEncoding{} }
func (m *RiceDeltaEncoding) String() string            { return proto.CompactTextString(m) }
func (*RiceDeltaEncoding) ProtoMessage()               {}
func (*RiceDeltaEncoding) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *RiceDeltaEncoding) GetFirstValue() int64 {
	if m != nil && m.FirstValue != nil {
		return *m.FirstValue
	}
	return 0
}

func (m *RiceDeltaEncoding) GetRiceParameter() int32 {
	if m != nil && m.RiceParameter != nil {
		return *m.RiceParameter
	}
	return 0
}

func (m *RiceDeltaEncoding) GetNumEntries() int32 {
	if m != nil && m.NumEntries != nil {
		return *m.NumEntries
	}
	return 0
}

func (m *RiceDeltaEncoding) GetEncodedData() []byte {
	if m != nil {
		return m.EncodedData
	}
	return nil
}

// The metadata associated with a specific threat entry. The client is expected
// to know the metadata key/value pairs associated with each threat type.
type ThreatEntryMetadata struct {
	// The metadata entries.
	Entries          []*ThreatEntryMetadata_MetadataEntry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
	XXX_unrecognized []byte                               `json:"-"`
}

func (m *ThreatEntryMetadata) Reset()                    { *m = ThreatEntryMetadata{} }
func (m *ThreatEntryMetadata) String() string            { return proto.CompactTextString(m) }
func (*ThreatEntryMetadata) ProtoMessage()               {}
func (*ThreatEntryMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ThreatEntryMetadata) GetEntries() []*ThreatEntryMetadata_MetadataEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// A single metadata entry.
type ThreatEntryMetadata_MetadataEntry struct {
	// The metadata entry key.
	Key []byte `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// The metadata entry value.
	Value            []byte `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ThreatEntryMetadata_MetadataEntry) Reset()         { *m = ThreatEntryMetadata_MetadataEntry{} }
func (m *ThreatEntryMetadata_MetadataEntry) String() string { return proto.CompactTextString(m) }
func (*ThreatEntryMetadata_MetadataEntry) ProtoMessage()    {}
func (*ThreatEntryMetadata_MetadataEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{17, 0}
}

func (m *ThreatEntryMetadata_MetadataEntry) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *ThreatEntryMetadata_MetadataEntry) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// Describes an individual threat list. A list is defined by three parameters:
// the type of threat posed, the type of platform targeted by the threat, and
// the type of entries in the list.
type ThreatListDescriptor struct {
	// The threat type posed by the list's entries.
	ThreatType *ThreatType `protobuf:"varint,1,opt,name=threat_type,json=threatType,enum=safebrowsing.ThreatType" json:"threat_type,omitempty"`
	// The platform type targeted by the list's entries.
	PlatformType *PlatformType `protobuf:"varint,2,opt,name=platform_type,json=platformType,enum=safebrowsing.PlatformType" json:"platform_type,omitempty"`
	// The entry types contained in the list.
	ThreatEntryType  *ThreatEntryType `protobuf:"varint,3,opt,name=threat_entry_type,json=threatEntryType,enum=safebrowsing.ThreatEntryType" json:"threat_entry_type,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *ThreatListDescriptor) Reset()                    { *m = ThreatListDescriptor{} }
func (m *ThreatListDescriptor) String() string            { return proto.CompactTextString(m) }
func (*ThreatListDescriptor) ProtoMessage()               {}
func (*ThreatListDescriptor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ThreatListDescriptor) GetThreatType() ThreatType {
	if m != nil && m.ThreatType != nil {
		return *m.ThreatType
	}
	return ThreatType_THREAT_TYPE_UNSPECIFIED
}

func (m *ThreatListDescriptor) GetPlatformType() PlatformType {
	if m != nil && m.PlatformType != nil {
		return *m.PlatformType
	}
	return PlatformType_PLATFORM_TYPE_UNSPECIFIED
}

func (m *ThreatListDescriptor) GetThreatEntryType() ThreatEntryType {
	if m != nil && m.ThreatEntryType != nil {
		return *m.ThreatEntryType
	}
	return ThreatEntryType_THREAT_ENTRY_TYPE_UNSPECIFIED
}

// A collection of lists available for download.
type ListThreatListsResponse struct {
	// The lists available for download.
	ThreatLists      []*ThreatListDescriptor `protobuf:"bytes,1,rep,name=threat_lists,json=threatLists" json:"threat_lists,omitempty"`
	XXX_unrecognized []byte                  `json:"-"`
}

func (m *ListThreatListsResponse) Reset()                    { *m = ListThreatListsResponse{} }
func (m *ListThreatListsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListThreatListsResponse) ProtoMessage()               {}
func (*ListThreatListsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *ListThreatListsResponse) GetThreatLists() []*ThreatListDescriptor {
	if m != nil {
		return m.ThreatLists
	}
	return nil
}

type Duration struct {
	// Signed seconds of the span of time. Must be from -315,576,000,000
	// to +315,576,000,000 inclusive.
	Seconds *int64 `protobuf:"varint,1,opt,name=seconds" json:"seconds,omitempty"`
	// Signed fractions of a second at nanosecond resolution of the span
	// of time. Durations less than one second are represented with a 0
	// `seconds` field and a positive or negative `nanos` field. For durations
	// of one second or more, a non-zero value for the `nanos` field must be
	// of the same sign as the `seconds` field. Must be from -999,999,999
	// to +999,999,999 inclusive.
	Nanos            *int32 `protobuf:"varint,2,opt,name=nanos" json:"nanos,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *Duration) Reset()                    { *m = Duration{} }
func (m *Duration) String() string            { return proto.CompactTextString(m) }
func (*Duration) ProtoMessage()               {}
func (*Duration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *Duration) GetSeconds() int64 {
	if m != nil && m.Seconds != nil {
		return *m.Seconds
	}
	return 0
}

func (m *Duration) GetNanos() int32 {
	if m != nil && m.Nanos != nil {
		return *m.Nanos
	}
	return 0
}

func init() {
	proto.RegisterType((*ThreatInfo)(nil), "safebrowsing.ThreatInfo")
	proto.RegisterType((*ThreatMatch)(nil), "safebrowsing.ThreatMatch")
	proto.RegisterType((*FindThreatMatchesRequest)(nil), "safebrowsing.FindThreatMatchesRequest")
	proto.RegisterType((*FindThreatMatchesResponse)(nil), "safebrowsing.FindThreatMatchesResponse")
	proto.RegisterType((*FetchThreatListUpdatesRequest)(nil), "safebrowsing.FetchThreatListUpdatesRequest")
	proto.RegisterType((*FetchThreatListUpdatesRequest_ListUpdateRequest)(nil), "safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest")
	proto.RegisterType((*FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints)(nil), "safebrowsing.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints")
	proto.RegisterType((*FetchThreatListUpdatesResponse)(nil), "safebrowsing.FetchThreatListUpdatesResponse")
	proto.RegisterType((*FetchThreatListUpdatesResponse_ListUpdateResponse)(nil), "safebrowsing.FetchThreatListUpdatesResponse.ListUpdateResponse")
	proto.RegisterType((*FindFullHashesRequest)(nil), "safebrowsing.FindFullHashesRequest")
	proto.RegisterType((*FindFullHashesResponse)(nil), "safebrowsing.FindFullHashesResponse")
	proto.RegisterType((*ThreatHit)(nil), "safebrowsing.ThreatHit")
	proto.RegisterType((*ThreatHit_ThreatSource)(nil), "safebrowsing.ThreatHit.ThreatSource")
	proto.RegisterType((*ClientInfo)(nil), "safebrowsing.ClientInfo")
	proto.RegisterType((*ChromeClientInfo)(nil), "safebrowsing.ChromeClientInfo")
	proto.RegisterType((*Checksum)(nil), "safebrowsing.Checksum")
	proto.RegisterType((*ThreatEntry)(nil), "safebrowsing.ThreatEntry")
	proto.RegisterType((*ThreatEntrySet)(nil), "safebrowsing.ThreatEntrySet")
	proto.RegisterType((*RawIndices)(nil), "safebrowsing.RawIndices")
	proto.RegisterType((*RawHashes)(nil), "safebrowsing.RawHashes")
	proto.RegisterType((*RiceDeltaEncoding)(nil), "safebrowsing.RiceDeltaEncoding")
	proto.RegisterType((*ThreatEntryMetadata)(nil), "safebrowsing.ThreatEntryMetadata")
	proto.RegisterType((*ThreatEntryMetadata_MetadataEntry)(nil), "safebrowsing.ThreatEntryMetadata.MetadataEntry")
	proto.RegisterType((*ThreatListDescriptor)(nil), "safebrowsing.ThreatListDescriptor")
	proto.RegisterType((*ListThreatListsResponse)(nil), "safebrowsing.ListThreatListsResponse")
	proto.RegisterType((*Duration)(nil), "safebrowsing.Duration")
	proto.RegisterEnum("safebrowsing.ThreatType", ThreatType_name, ThreatType_value)
	proto.RegisterEnum("safebrowsing.PlatformType", PlatformType_name, PlatformType_value)
	proto.RegisterEnum("safebrowsing.CompressionType", CompressionType_name, CompressionType_value)
	proto.RegisterEnum("safebrowsing.ThreatEntryType", ThreatEntryType_name, ThreatEntryType_value)
	proto.RegisterEnum("safebrowsing.FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType", FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_name, FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_value)
	proto.RegisterEnum("safebrowsing.ThreatHit_ThreatSourceType", ThreatHit_ThreatSourceType_name, ThreatHit_ThreatSourceType_value)
	proto.RegisterEnum("safebrowsing.ChromeClientInfo_SafeBrowsingReportingPopulation", ChromeClientInfo_SafeBrowsingReportingPopulation_name, ChromeClientInfo_SafeBrowsingReportingPopulation_value)
}

func init() { proto.RegisterFile("safebrowsing.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2055 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x4b, 0x8f, 0xe3, 0x58,
	0x15, 0xc6, 0x49, 0xa5, 0x2a, 0x39, 0x79, 0x94, 0xfb, 0xd6, 0xa3, 0xd3, 0xc5, 0xf4, 0xcb, 0x03,
	0xa8, 0xd5, 0x42, 0x35, 0x43, 0x8f, 0x18, 0x60, 0x60, 0x98, 0x71, 0x1c, 0xa7, 0x63, 0xc6, 0x65,
	0x47, 0xd7, 0xce, 0x54, 0xf7, 0xca, 0x78, 0x92, 0x5b, 0x5d, 0x56, 0x27, 0x76, 0xda, 0x76, 0xba,
	0xba, 0xe7, 0x0f, 0x20, 0x7e, 0x01, 0x42, 0x08, 0xb1, 0xe6, 0x37, 0xf0, 0x13, 0x90, 0xd8, 0xb0,
	0x03, 0x21, 0xd6, 0x2c, 0xd8, 0xb2, 0x05, 0xdd, 0x87, 0x63, 0x27, 0x95, 0xaa, 0xea, 0xe9, 0x42,
	0x9a, 0xd9, 0xf9, 0x9e, 0xc7, 0x77, 0xcf, 0x3d, 0xf7, 0xbc, 0xae, 0x01, 0x25, 0xfe, 0x09, 0xf9,
	0x22, 0x8e, 0xce, 0x92, 0x20, 0x7c, 0x76, 0x38, 0x8b, 0xa3, 0x34, 0x42, 0x8d, 0x22, 0x4d, 0xf9,
	0x5d, 0x09, 0xc0, 0x3d, 0x8d, 0x89, 0x9f, 0x1a, 0xe1, 0x49, 0x84, 0x7e, 0x0a, 0x8d, 0x94, 0xad,
	0xbc, 0xf4, 0xf5, 0x8c, 0x24, 0x6d, 0xe9, 0x5e, 0xf9, 0x41, 0xeb, 0x51, 0xfb, 0x70, 0x09, 0x87,
	0xcb, 0xbb, 0xaf, 0x67, 0x04, 0xd7, 0xd3, 0xc5, 0x77, 0x82, 0x54, 0x68, 0xcd, 0x26, 0x7e, 0x7a,
	0x12, 0xc5, 0x53, 0xa1, 0x5e, 0x62, 0xea, 0x07, 0xcb, 0xea, 0x03, 0x21, 0xc3, 0x00, 0x9a, 0xb3,
	0xc2, 0x2a, 0x41, 0x9f, 0x01, 0x12, 0xfb, 0x93, 0x30, 0x8d, 0x5f, 0x0b, 0x98, 0x0d, 0x06, 0x73,
	0x7b, 0x9d, 0x15, 0x3a, 0x15, 0x63, 0x48, 0x72, 0xba, 0x4c, 0x48, 0xd0, 0xa7, 0xd0, 0x2a, 0x80,
	0x05, 0x24, 0x69, 0x97, 0xef, 0x95, 0x1f, 0xd4, 0x1f, 0xdd, 0xba, 0x10, 0x08, 0x37, 0x73, 0x90,
	0x80, 0x24, 0xca, 0xef, 0xcb, 0x50, 0xe7, 0xec, 0x23, 0x3f, 0x1d, 0x9d, 0xa2, 0x9f, 0x40, 0xbd,
	0xe0, 0x9e, 0xb6, 0x74, 0x4f, 0xba, 0xd4, 0x3b, 0x90, 0x7b, 0x07, 0x7d, 0x02, 0xcd, 0x25, 0xe7,
	0xb4, 0x4b, 0x4c, 0xf9, 0x32, 0xdf, 0x34, 0x8a, 0xbe, 0x41, 0x06, 0xdc, 0x38, 0xe7, 0x9a, 0xf6,
	0x26, 0x03, 0xb9, 0xc2, 0x33, 0xdb, 0x2b, 0x9e, 0x41, 0x3f, 0x80, 0x4d, 0x4e, 0x6a, 0x97, 0xef,
	0x49, 0x97, 0x3b, 0x44, 0x08, 0xa2, 0x21, 0xec, 0x2d, 0xed, 0x3e, 0x25, 0xa9, 0x3f, 0xf6, 0x53,
	0xbf, 0xbd, 0xc1, 0x10, 0xee, 0x5f, 0x88, 0x70, 0x24, 0x04, 0xf1, 0x4e, 0x7a, 0x9e, 0x88, 0x3e,
	0x86, 0xd6, 0xc8, 0x1f, 0x9d, 0x12, 0x6f, 0x3c, 0x8f, 0xfd, 0x34, 0x88, 0xc2, 0x76, 0x85, 0xe1,
	0xed, 0x2f, 0xe3, 0x75, 0x05, 0x17, 0x37, 0x99, 0x74, 0xb6, 0x54, 0x7e, 0x25, 0x41, 0xbb, 0x17,
	0x84, 0xe3, 0xc2, 0x1d, 0x91, 0x04, 0x93, 0x17, 0x73, 0x92, 0xa4, 0xe8, 0x7d, 0xd8, 0x1c, 0x4d,
	0x02, 0x12, 0xa6, 0xec, 0x9e, 0xea, 0xab, 0xf7, 0xa4, 0x31, 0x1e, 0x8d, 0x7a, 0x2c, 0xe4, 0x0a,
	0xd7, 0x1b, 0x84, 0x27, 0x11, 0xbb, 0xa1, 0xfa, 0xfa, 0xeb, 0x65, 0x6a, 0xe2, 0x7a, 0xe9, 0xb7,
	0x32, 0x80, 0x5b, 0x6b, 0x0c, 0x49, 0x66, 0x51, 0x98, 0x10, 0xf4, 0x01, 0x6c, 0x4d, 0x39, 0x89,
	0x25, 0xd4, 0x05, 0x0e, 0x67, 0x5a, 0x38, 0x93, 0x54, 0xfe, 0xb2, 0x09, 0xb7, 0x7b, 0x24, 0x1d,
	0x9d, 0x72, 0xae, 0x19, 0x24, 0xe9, 0x70, 0x36, 0xf6, 0xd3, 0xeb, 0x1c, 0x30, 0x82, 0xdd, 0x49,
	0x90, 0xa4, 0xde, 0x9c, 0x01, 0x79, 0x31, 0x07, 0xca, 0xf2, 0xe2, 0xe3, 0x65, 0xfd, 0x4b, 0x37,
	0x3f, 0xcc, 0x49, 0x82, 0x82, 0xd1, 0x64, 0x95, 0x94, 0x20, 0x13, 0xd0, 0xe8, 0x34, 0x8e, 0xa6,
	0xc4, 0xe3, 0x16, 0x70, 0xc7, 0xf2, 0x98, 0xb9, 0xb3, 0x62, 0x2e, 0x93, 0x2b, 0x18, 0x2d, 0x8f,
	0x56, 0x28, 0x07, 0x7f, 0xda, 0x80, 0x1b, 0xe7, 0xf6, 0xfd, 0xe6, 0x25, 0x65, 0xe5, 0xad, 0x92,
	0x72, 0x17, 0x2a, 0x49, 0xea, 0xa7, 0x84, 0xe5, 0x64, 0x03, 0xf3, 0x05, 0x7a, 0x0e, 0xf5, 0x51,
	0x14, 0x26, 0x69, 0xec, 0x07, 0x61, 0x9a, 0x08, 0xcf, 0x19, 0xd7, 0xba, 0xa8, 0x43, 0x2d, 0x07,
	0xc4, 0x45, 0xf4, 0x83, 0xbf, 0x4b, 0x50, 0x2f, 0x30, 0xd1, 0xf7, 0x01, 0x4d, 0xfd, 0x57, 0x59,
	0xb4, 0x64, 0x45, 0x94, 0x3a, 0xb8, 0x82, 0xe5, 0xa9, 0xff, 0x8a, 0xc3, 0x8a, 0x62, 0x89, 0xde,
	0x87, 0x5d, 0x2a, 0x4d, 0xf3, 0xfa, 0x0b, 0x3f, 0xc9, 0xe5, 0x4b, 0x4c, 0x9e, 0x22, 0x75, 0x05,
	0x2b, 0xd3, 0xd8, 0x87, 0xcd, 0x98, 0x3c, 0xa3, 0x59, 0x4f, 0xcf, 0x5c, 0xc3, 0x62, 0x85, 0x5c,
	0xd8, 0x4f, 0xe6, 0xb3, 0x59, 0x14, 0xa7, 0x64, 0xec, 0x8d, 0xa2, 0xe9, 0x2c, 0x26, 0x49, 0x12,
	0x44, 0xe1, 0x05, 0x9d, 0x40, 0xcb, 0x25, 0x98, 0x6b, 0xf7, 0x16, 0xca, 0x05, 0x4e, 0xa2, 0xfc,
	0x6d, 0x13, 0xee, 0x5c, 0xe4, 0x2a, 0x91, 0xa8, 0x09, 0xec, 0x2d, 0xe7, 0x07, 0xa7, 0x67, 0x69,
	0xfb, 0xc9, 0x9b, 0xf9, 0x9d, 0x2b, 0x2d, 0x39, 0x9e, 0x93, 0xf0, 0xce, 0xe4, 0x1c, 0x2d, 0x41,
	0xbf, 0x80, 0xbd, 0x69, 0x10, 0x06, 0xd3, 0xf9, 0xd4, 0x3b, 0xf3, 0x83, 0x34, 0x2f, 0x85, 0xa5,
	0x4b, 0x4b, 0xe1, 0x8e, 0x50, 0x3a, 0xf6, 0x83, 0x34, 0x23, 0x1e, 0xfc, 0x67, 0x03, 0xd0, 0xf9,
	0x7d, 0xaf, 0x93, 0x22, 0x6b, 0x23, 0xbc, 0xf4, 0x56, 0x11, 0x7e, 0x2e, 0xdb, 0xca, 0x5f, 0x31,
	0xdb, 0x5e, 0x40, 0x33, 0xbb, 0x12, 0x0e, 0xb0, 0xc1, 0x00, 0xcc, 0x6b, 0x5e, 0xcb, 0x61, 0xf6,
	0xc1, 0xb7, 0x8c, 0x0b, 0x2b, 0xf4, 0x11, 0xd4, 0xfc, 0xf1, 0x38, 0x48, 0x59, 0xf4, 0x55, 0x58,
	0x14, 0xbc, 0x73, 0xe1, 0xb1, 0x1d, 0x92, 0xe2, 0x5c, 0x1c, 0xfd, 0x18, 0xaa, 0x31, 0x99, 0x46,
	0x2f, 0xfd, 0x49, 0xd2, 0xde, 0x7c, 0x03, 0xd5, 0x85, 0x34, 0x7a, 0x00, 0x72, 0x48, 0xce, 0xb2,
	0x9a, 0xc9, 0xcb, 0xc2, 0x16, 0x2b, 0x0b, 0xad, 0x90, 0x9c, 0xf1, 0x8a, 0xe8, 0xb0, 0xfa, 0xf0,
	0x08, 0xaa, 0xa3, 0x53, 0x32, 0x7a, 0x9e, 0xcc, 0xa7, 0xed, 0xea, 0xba, 0x78, 0xd1, 0x04, 0x17,
	0x2f, 0xe4, 0x14, 0x0c, 0x8d, 0xe2, 0x89, 0xd1, 0x6d, 0xb8, 0x85, 0x75, 0x67, 0x60, 0x5b, 0x8e,
	0xee, 0xb9, 0x4f, 0x07, 0xba, 0x37, 0xb4, 0x9c, 0x81, 0xae, 0x19, 0x3d, 0x43, 0xef, 0xca, 0xdf,
	0x42, 0x08, 0x5a, 0x03, 0x15, 0xbb, 0x86, 0x6a, 0x7a, 0xc3, 0x41, 0x57, 0x75, 0x75, 0x59, 0x42,
	0xdb, 0x50, 0xef, 0x0d, 0xcd, 0x05, 0xa1, 0xa4, 0xfc, 0x51, 0x82, 0x3d, 0xda, 0x00, 0x7b, 0xf3,
	0xc9, 0xa4, 0xef, 0x27, 0xd7, 0x6a, 0xc3, 0xef, 0x42, 0xb3, 0x78, 0x72, 0x3e, 0x46, 0x36, 0x70,
	0x63, 0x94, 0x9f, 0x3b, 0x59, 0xed, 0xd5, 0xe5, 0xaf, 0xd0, 0xab, 0xff, 0x25, 0xc1, 0xfe, 0xaa,
	0xad, 0xd7, 0xe8, 0xd4, 0xff, 0xcf, 0x04, 0x46, 0x16, 0xdc, 0x0c, 0xc9, 0x33, 0x3f, 0x0d, 0x5e,
	0x12, 0x6f, 0x65, 0x32, 0x2a, 0x5f, 0x8a, 0xb6, 0x97, 0xa9, 0x69, 0x4b, 0x13, 0xd2, 0x7f, 0xcb,
	0x50, 0xe3, 0x46, 0xf7, 0x83, 0xaf, 0xb7, 0x55, 0xbe, 0x07, 0x15, 0x56, 0x41, 0xae, 0x9e, 0x39,
	0xb9, 0x1c, 0xea, 0x40, 0x2d, 0x26, 0x49, 0x34, 0x8f, 0x47, 0xe2, 0x09, 0x50, 0x7f, 0xf4, 0x9d,
	0x75, 0x4a, 0xfd, 0x20, 0x15, 0x5f, 0x0e, 0x13, 0xc6, 0xb9, 0xda, 0xc1, 0x6f, 0x24, 0x68, 0x14,
	0x79, 0x48, 0x86, 0xf2, 0x3c, 0x9e, 0xb0, 0x93, 0xd7, 0x30, 0xfd, 0x44, 0x3f, 0x83, 0x8d, 0xc2,
	0x79, 0x1e, 0xbc, 0xc9, 0x0e, 0xec, 0x74, 0x4c, 0x0b, 0x7d, 0x9b, 0x1a, 0x39, 0x8d, 0x52, 0xe2,
	0x05, 0x33, 0xd1, 0xc5, 0xaa, 0x9c, 0x60, 0xcc, 0xd0, 0x01, 0x2d, 0x00, 0x27, 0x24, 0x8e, 0x49,
	0xcc, 0x4a, 0x15, 0xe3, 0xf1, 0xb5, 0xf2, 0x0c, 0xe4, 0x55, 0x48, 0xa4, 0xc0, 0x1d, 0xb7, 0x8f,
	0x75, 0xd5, 0xf5, 0x1c, 0x7b, 0x88, 0xb5, 0xb5, 0xd9, 0x28, 0x43, 0xe3, 0x48, 0x75, 0xb5, 0xbe,
	0x61, 0x3d, 0xf6, 0x86, 0xd8, 0x94, 0x25, 0x54, 0x87, 0x2d, 0x57, 0xed, 0xb0, 0x45, 0x89, 0xb2,
	0xe9, 0x02, 0xeb, 0x5d, 0x03, 0xeb, 0x9a, 0x2b, 0x97, 0x95, 0x01, 0x40, 0x9e, 0x63, 0xd4, 0xde,
	0x6c, 0x12, 0x1b, 0x0b, 0x2f, 0x54, 0x39, 0xc1, 0x18, 0xa3, 0xef, 0x42, 0x4b, 0x30, 0x5f, 0x92,
	0x38, 0xc9, 0x22, 0xb8, 0x86, 0x45, 0x3a, 0x7e, 0xce, 0x89, 0xca, 0x3f, 0x25, 0x90, 0x57, 0xa7,
	0x35, 0xf4, 0x02, 0x76, 0x63, 0x42, 0xbb, 0x6e, 0x10, 0x3e, 0xf3, 0x66, 0xd1, 0x6c, 0x3e, 0xe1,
	0x51, 0xcb, 0x63, 0xec, 0xe7, 0x97, 0xcf, 0x7a, 0x87, 0x8e, 0x7f, 0x42, 0x3a, 0x82, 0x8b, 0x33,
	0x98, 0xc1, 0x02, 0x05, 0xef, 0xc4, 0xe7, 0x89, 0xca, 0x13, 0xb8, 0x7b, 0x85, 0x1e, 0xad, 0x53,
	0xcb, 0xee, 0xab, 0xc3, 0x96, 0x3d, 0x70, 0x3d, 0x7b, 0xe8, 0xca, 0x12, 0x6a, 0x40, 0x55, 0x7f,
	0xe2, 0xea, 0x56, 0x57, 0xef, 0xca, 0x25, 0x54, 0x83, 0x8a, 0xa3, 0x51, 0x46, 0x59, 0x51, 0xa0,
	0x9a, 0xd5, 0x4d, 0x3a, 0xa4, 0x24, 0xa7, 0xfe, 0xa3, 0x1f, 0x7e, 0xc8, 0x8e, 0xd2, 0xc0, 0x62,
	0xa5, 0x7c, 0x90, 0x3d, 0x0d, 0x59, 0xd0, 0x22, 0x04, 0x1b, 0xa7, 0x7e, 0x72, 0x2a, 0x84, 0xd8,
	0x77, 0x16, 0x6c, 0xa5, 0x45, 0xb0, 0x29, 0x7f, 0x2d, 0x41, 0x6b, 0xb9, 0xea, 0xa3, 0x3e, 0xc8,
	0x85, 0x11, 0xa7, 0x98, 0x98, 0x57, 0x8c, 0x39, 0xdb, 0xa3, 0x65, 0x02, 0xfa, 0x10, 0x20, 0xf6,
	0xcf, 0xbc, 0x53, 0x56, 0xd2, 0x44, 0xf1, 0xb9, 0xb9, 0x8c, 0x81, 0xfd, 0x33, 0x51, 0xf1, 0x6a,
	0x71, 0xf6, 0x49, 0xab, 0x02, 0xd5, 0x0b, 0xc2, 0x71, 0x30, 0x62, 0x8f, 0xe4, 0x35, 0xa5, 0x14,
	0xfb, 0x67, 0x06, 0xe7, 0x63, 0xba, 0x89, 0xf8, 0x46, 0x9f, 0x42, 0x3d, 0x0e, 0x46, 0x24, 0xdb,
	0x93, 0x8f, 0xa7, 0x77, 0x57, 0x54, 0x83, 0x11, 0xe9, 0x92, 0x49, 0xea, 0xeb, 0xe1, 0x28, 0x1a,
	0xd3, 0x8b, 0x02, 0xaa, 0x23, 0x36, 0xef, 0x40, 0x83, 0x21, 0x64, 0xbb, 0x57, 0xde, 0x0c, 0x82,
	0x6d, 0x2b, 0xac, 0x50, 0xbe, 0x07, 0x90, 0xdb, 0x87, 0xda, 0xb0, 0x95, 0x81, 0xd1, 0x1a, 0x5e,
	0xc1, 0xd9, 0x52, 0xf9, 0x0c, 0x6a, 0x0b, 0x07, 0xa0, 0xbb, 0x50, 0x9f, 0xc5, 0xe4, 0x24, 0x78,
	0xe5, 0x25, 0xc1, 0x97, 0x44, 0x4c, 0xb5, 0xc0, 0x49, 0x4e, 0xf0, 0x25, 0x6d, 0x8b, 0xab, 0xee,
	0x6c, 0x14, 0xbc, 0xa6, 0xfc, 0x41, 0x82, 0x1b, 0xe7, 0xec, 0xa2, 0xa8, 0x27, 0x41, 0x9c, 0xa4,
	0xde, 0x4b, 0x7f, 0x32, 0xe7, 0xa8, 0x65, 0x0c, 0x8c, 0xf4, 0x39, 0xa5, 0xd0, 0x1c, 0x63, 0xe7,
	0x9d, 0xf9, 0xb1, 0x3f, 0x25, 0x29, 0x89, 0xc5, 0x7c, 0xdc, 0xa4, 0xd4, 0x41, 0x46, 0xa4, 0x38,
	0xe1, 0x7c, 0x5a, 0xf8, 0x71, 0xc1, 0xac, 0x0b, 0xe7, 0xd3, 0x6c, 0x76, 0xbe, 0x0f, 0x0d, 0x42,
	0x37, 0x25, 0x63, 0x6f, 0xf1, 0x0e, 0x6f, 0xe0, 0xba, 0xa0, 0xd1, 0x49, 0x5b, 0xf9, 0xad, 0x04,
	0x3b, 0x6b, 0x5e, 0xe2, 0xc8, 0x80, 0xad, 0x7c, 0x96, 0xa7, 0x65, 0xf5, 0xbd, 0x2b, 0x5f, 0xef,
	0x87, 0xd9, 0x07, 0xaf, 0xd0, 0x99, 0xfe, 0xc1, 0x8f, 0xa0, 0xb9, 0xc4, 0xa1, 0x21, 0xff, 0x9c,
	0xbc, 0x16, 0x59, 0x40, 0x3f, 0xe9, 0xbb, 0x86, 0xfb, 0x82, 0x7b, 0x90, 0x2f, 0x94, 0x7f, 0x48,
	0xb0, 0x9b, 0xcf, 0x68, 0x5d, 0x92, 0x8c, 0xe2, 0x60, 0x96, 0x46, 0xf1, 0x37, 0xef, 0x35, 0x57,
	0x7e, 0x9b, 0x59, 0x57, 0xf9, 0x25, 0xdc, 0xa4, 0x07, 0xcb, 0x8f, 0x98, 0xcf, 0x18, 0xfa, 0xe2,
	0x1f, 0x1b, 0x7d, 0x0d, 0x64, 0x77, 0xa0, 0xac, 0xdb, 0x60, 0xd9, 0x37, 0xd9, 0xdf, 0x36, 0x06,
	0xa7, 0x7c, 0x04, 0xd5, 0xc5, 0xd4, 0xd0, 0x86, 0xad, 0x84, 0x8c, 0xa2, 0x70, 0x9c, 0x88, 0x88,
	0xcb, 0x96, 0xd4, 0xfb, 0xa1, 0x1f, 0x46, 0xd9, 0x2b, 0x8c, 0x2f, 0x1e, 0xfe, 0x7b, 0xf1, 0xd7,
	0xcf, 0xe5, 0x4d, 0xec, 0xa6, 0xe8, 0x3b, 0xeb, 0xc7, 0xbf, 0x23, 0xd5, 0x3c, 0x56, 0xb1, 0xee,
	0x71, 0x21, 0x59, 0xa2, 0x13, 0xa3, 0x63, 0x6b, 0x74, 0x22, 0xd4, 0xad, 0xc7, 0x86, 0xa5, 0xeb,
	0x98, 0xb6, 0xa3, 0xc1, 0xb0, 0x63, 0x1a, 0x9a, 0x5c, 0x42, 0x7b, 0x70, 0x63, 0x68, 0x1d, 0xab,
	0x96, 0xab, 0x77, 0x3d, 0xc7, 0xee, 0xb9, 0x54, 0x59, 0x2e, 0xa3, 0x77, 0xe1, 0xee, 0xc0, 0x76,
	0x75, 0x8b, 0x8e, 0x92, 0xe6, 0x53, 0xaf, 0xaf, 0xe2, 0xa3, 0xde, 0xd0, 0xf4, 0xd4, 0xc1, 0xc0,
	0x34, 0x34, 0xd5, 0x35, 0x6c, 0x4b, 0xde, 0x40, 0xfb, 0x80, 0xce, 0x43, 0xcb, 0x15, 0xd4, 0x84,
	0x9a, 0x3a, 0x30, 0x3c, 0xb5, 0x33, 0x74, 0x74, 0x79, 0x13, 0xed, 0x82, 0x7c, 0xa4, 0x9a, 0x86,
	0x66, 0xd8, 0x43, 0xc7, 0xeb, 0x18, 0x96, 0x8a, 0x9f, 0xca, 0x5b, 0xe8, 0x06, 0x34, 0x35, 0xa7,
	0xeb, 0x1d, 0xf7, 0x0d, 0x57, 0x37, 0x0d, 0xc7, 0x95, 0xab, 0xe8, 0x00, 0xf6, 0x29, 0xa9, 0x6b,
	0x1f, 0x5b, 0xa6, 0xad, 0x16, 0x79, 0x35, 0xb4, 0x03, 0xdb, 0x9a, 0x69, 0xe8, 0x96, 0xeb, 0x19,
	0x96, 0x66, 0x74, 0x75, 0xcb, 0x95, 0x81, 0x19, 0x30, 0xec, 0x60, 0x5d, 0xb4, 0xe0, 0x9e, 0x61,
	0xba, 0x3a, 0x96, 0x9b, 0xa8, 0x05, 0xe0, 0x0c, 0x9d, 0x01, 0xdf, 0x52, 0x6e, 0xd1, 0x4e, 0xd2,
	0x31, 0x4c, 0x93, 0x5a, 0xb7, 0x4d, 0x1d, 0xd2, 0x37, 0x1e, 0xf7, 0x3d, 0xcd, 0xb6, 0x7a, 0x14,
	0x48, 0xd3, 0x3d, 0xd5, 0x34, 0xed, 0x63, 0xb6, 0x91, 0xfc, 0xf0, 0xcf, 0x12, 0x34, 0x8a, 0x71,
	0x47, 0xe5, 0x07, 0xa6, 0xea, 0xf6, 0x6c, 0x7c, 0xb4, 0xce, 0xe7, 0xbb, 0x20, 0x1f, 0x1b, 0x56,
	0xd7, 0x3e, 0x76, 0xbc, 0x4c, 0x4c, 0x96, 0xe8, 0x4d, 0x98, 0x86, 0x35, 0x7c, 0x92, 0xd3, 0x4a,
	0x54, 0x52, 0xb5, 0xba, 0xd8, 0x36, 0xba, 0x39, 0xb5, 0x4c, 0xa7, 0x00, 0xdb, 0x29, 0xc8, 0x6d,
	0x50, 0x8a, 0x61, 0x17, 0xd0, 0x2a, 0x94, 0xa2, 0x5a, 0x4f, 0x73, 0xca, 0x26, 0xf5, 0x9e, 0x6a,
	0x9a, 0x0b, 0x8a, 0x23, 0x6f, 0x31, 0x0f, 0xf5, 0xb1, 0x7d, 0xa4, 0xe7, 0x72, 0xd5, 0x87, 0x3d,
	0xd8, 0x5e, 0xe9, 0x45, 0xe8, 0x1e, 0xbc, 0xa3, 0xd9, 0x47, 0x03, 0xac, 0x3b, 0x8e, 0x61, 0x5b,
	0xeb, 0x8e, 0xb4, 0x05, 0x65, 0xac, 0x1e, 0xcb, 0x12, 0xaa, 0xc2, 0x06, 0x36, 0x34, 0x5d, 0x2e,
	0x3d, 0xfc, 0xb5, 0x04, 0xdb, 0x2b, 0x89, 0x84, 0xee, 0xc3, 0x6d, 0x11, 0x8a, 0xba, 0xe5, 0xe2,
	0xa7, 0x17, 0x20, 0xf1, 0xc1, 0xa7, 0x05, 0xa0, 0x3f, 0xd1, 0xb5, 0xa1, 0xab, 0x76, 0x4c, 0x5d,
	0x2e, 0xd1, 0x76, 0x6e, 0x0c, 0x3c, 0xac, 0x5a, 0x8f, 0x69, 0xb4, 0xed, 0x82, 0x2c, 0x4c, 0x67,
	0x3d, 0xde, 0xe1, 0xe1, 0xd5, 0x80, 0x6a, 0xcf, 0x30, 0x75, 0x4b, 0x3d, 0xd2, 0xe5, 0x0a, 0xb5,
	0x45, 0xd3, 0xb1, 0x2b, 0x6f, 0x76, 0x4a, 0xfd, 0xf2, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xa8,
	0xf8, 0x8c, 0xdc, 0x2e, 0x17, 0x00, 0x00,
}
