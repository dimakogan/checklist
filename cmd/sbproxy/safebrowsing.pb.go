// Code generated by protoc-gen-go. DO NOT EDIT.
// source: safebrowsing.proto

/*
Package main is a generated protocol buffer package.

It is generated from these files:
	safebrowsing.proto

It has these top-level messages:
	ThreatInfo
	ThreatMatch
	FindThreatMatchesRequest
	FindThreatMatchesResponse
	FetchThreatListUpdatesRequest
	FetchThreatListUpdatesResponse
	FindFullHashesRequest
	FindFullHashesResponse
	ClientInfo
	Checksum
	ThreatEntry
	ThreatEntrySet
	RawIndices
	RawHashes
	RiceDeltaEncoding
	ThreatEntryMetadata
	ThreatListDescriptor
	ListThreatListsResponse
*/
package main

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/duration"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Types of threats.
type ThreatType int32

const (
	// Unknown.
	ThreatType_THREAT_TYPE_UNSPECIFIED ThreatType = 0
	// Malware threat type.
	ThreatType_MALWARE ThreatType = 1
	// Social engineering threat type.
	ThreatType_SOCIAL_ENGINEERING ThreatType = 2
	// Unwanted software threat type.
	ThreatType_UNWANTED_SOFTWARE ThreatType = 3
	// Potentially harmful application threat type.
	ThreatType_POTENTIALLY_HARMFUL_APPLICATION ThreatType = 4
)

var ThreatType_name = map[int32]string{
	0: "THREAT_TYPE_UNSPECIFIED",
	1: "MALWARE",
	2: "SOCIAL_ENGINEERING",
	3: "UNWANTED_SOFTWARE",
	4: "POTENTIALLY_HARMFUL_APPLICATION",
}
var ThreatType_value = map[string]int32{
	"THREAT_TYPE_UNSPECIFIED":         0,
	"MALWARE":                         1,
	"SOCIAL_ENGINEERING":              2,
	"UNWANTED_SOFTWARE":               3,
	"POTENTIALLY_HARMFUL_APPLICATION": 4,
}

func (x ThreatType) String() string {
	return proto.EnumName(ThreatType_name, int32(x))
}
func (ThreatType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Types of platforms.
type PlatformType int32

const (
	// Unknown platform.
	PlatformType_PLATFORM_TYPE_UNSPECIFIED PlatformType = 0
	// Threat posed to Windows.
	PlatformType_WINDOWS PlatformType = 1
	// Threat posed to Linux.
	PlatformType_LINUX PlatformType = 2
	// Threat posed to Android.
	PlatformType_ANDROID PlatformType = 3
	// Threat posed to OSX.
	PlatformType_OSX PlatformType = 4
	// Threat posed to iOS.
	PlatformType_IOS PlatformType = 5
	// Threat posed to at least one of the defined platforms.
	PlatformType_ANY_PLATFORM PlatformType = 6
	// Threat posed to all defined platforms.
	PlatformType_ALL_PLATFORMS PlatformType = 7
	// Threat posed to Chrome.
	PlatformType_CHROME PlatformType = 8
)

var PlatformType_name = map[int32]string{
	0: "PLATFORM_TYPE_UNSPECIFIED",
	1: "WINDOWS",
	2: "LINUX",
	3: "ANDROID",
	4: "OSX",
	5: "IOS",
	6: "ANY_PLATFORM",
	7: "ALL_PLATFORMS",
	8: "CHROME",
}
var PlatformType_value = map[string]int32{
	"PLATFORM_TYPE_UNSPECIFIED": 0,
	"WINDOWS":                   1,
	"LINUX":                     2,
	"ANDROID":                   3,
	"OSX":                       4,
	"IOS":                       5,
	"ANY_PLATFORM":              6,
	"ALL_PLATFORMS":             7,
	"CHROME":                    8,
}

func (x PlatformType) String() string {
	return proto.EnumName(PlatformType_name, int32(x))
}
func (PlatformType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// The ways in which threat entry sets can be compressed.
type CompressionType int32

const (
	// Unknown.
	CompressionType_COMPRESSION_TYPE_UNSPECIFIED CompressionType = 0
	// Raw, uncompressed data.
	CompressionType_RAW CompressionType = 1
	// Rice-Golomb encoded data.
	CompressionType_RICE CompressionType = 2
)

var CompressionType_name = map[int32]string{
	0: "COMPRESSION_TYPE_UNSPECIFIED",
	1: "RAW",
	2: "RICE",
}
var CompressionType_value = map[string]int32{
	"COMPRESSION_TYPE_UNSPECIFIED": 0,
	"RAW":  1,
	"RICE": 2,
}

func (x CompressionType) String() string {
	return proto.EnumName(CompressionType_name, int32(x))
}
func (CompressionType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// Types of entries that pose threats. Threat lists are collections of entries
// of a single type.
type ThreatEntryType int32

const (
	// Unspecified.
	ThreatEntryType_THREAT_ENTRY_TYPE_UNSPECIFIED ThreatEntryType = 0
	// A URL.
	ThreatEntryType_URL ThreatEntryType = 1
	// An executable program.
	ThreatEntryType_EXECUTABLE ThreatEntryType = 2
	// An IP range.
	ThreatEntryType_IP_RANGE ThreatEntryType = 3
)

var ThreatEntryType_name = map[int32]string{
	0: "THREAT_ENTRY_TYPE_UNSPECIFIED",
	1: "URL",
	2: "EXECUTABLE",
	3: "IP_RANGE",
}
var ThreatEntryType_value = map[string]int32{
	"THREAT_ENTRY_TYPE_UNSPECIFIED": 0,
	"URL":        1,
	"EXECUTABLE": 2,
	"IP_RANGE":   3,
}

func (x ThreatEntryType) String() string {
	return proto.EnumName(ThreatEntryType_name, int32(x))
}
func (ThreatEntryType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// The type of response sent to the client.
type FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType int32

const (
	// Unknown.
	FetchThreatListUpdatesResponse_ListUpdateResponse_RESPONSE_TYPE_UNSPECIFIED FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType = 0
	// Partial updates are applied to the client's existing local database.
	FetchThreatListUpdatesResponse_ListUpdateResponse_PARTIAL_UPDATE FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType = 1
	// Full updates replace the client's entire local database. This means
	// that either the client was seriously out-of-date or the client is
	// believed to be corrupt.
	FetchThreatListUpdatesResponse_ListUpdateResponse_FULL_UPDATE FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType = 2
)

var FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_name = map[int32]string{
	0: "RESPONSE_TYPE_UNSPECIFIED",
	1: "PARTIAL_UPDATE",
	2: "FULL_UPDATE",
}
var FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_value = map[string]int32{
	"RESPONSE_TYPE_UNSPECIFIED": 0,
	"PARTIAL_UPDATE":            1,
	"FULL_UPDATE":               2,
}

func (x FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType) String() string {
	return proto.EnumName(FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_name, int32(x))
}
func (FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{5, 0, 0}
}

// The information regarding one or more threats that a client submits when
// checking for matches in threat lists.
type ThreatInfo struct {
	// The threat types to be checked.
	ThreatTypes []ThreatType `protobuf:"varint,1,rep,packed,name=threat_types,json=threatTypes,enum=main.ThreatType" json:"threat_types,omitempty"`
	// The platform types to be checked.
	PlatformTypes []PlatformType `protobuf:"varint,2,rep,packed,name=platform_types,json=platformTypes,enum=main.PlatformType" json:"platform_types,omitempty"`
	// The entry types to be checked.
	ThreatEntryTypes []ThreatEntryType `protobuf:"varint,4,rep,packed,name=threat_entry_types,json=threatEntryTypes,enum=main.ThreatEntryType" json:"threat_entry_types,omitempty"`
	// The threat entries to be checked.
	ThreatEntries []*ThreatEntry `protobuf:"bytes,3,rep,name=threat_entries,json=threatEntries" json:"threat_entries,omitempty"`
}

func (m *ThreatInfo) Reset()                    { *m = ThreatInfo{} }
func (m *ThreatInfo) String() string            { return proto.CompactTextString(m) }
func (*ThreatInfo) ProtoMessage()               {}
func (*ThreatInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ThreatInfo) GetThreatTypes() []ThreatType {
	if m != nil {
		return m.ThreatTypes
	}
	return nil
}

func (m *ThreatInfo) GetPlatformTypes() []PlatformType {
	if m != nil {
		return m.PlatformTypes
	}
	return nil
}

func (m *ThreatInfo) GetThreatEntryTypes() []ThreatEntryType {
	if m != nil {
		return m.ThreatEntryTypes
	}
	return nil
}

func (m *ThreatInfo) GetThreatEntries() []*ThreatEntry {
	if m != nil {
		return m.ThreatEntries
	}
	return nil
}

// A match when checking a threat entry in the Safe Browsing threat lists.
type ThreatMatch struct {
	// The threat type matching this threat.
	ThreatType ThreatType `protobuf:"varint,1,opt,name=threat_type,json=threatType,enum=main.ThreatType" json:"threat_type,omitempty"`
	// The platform type matching this threat.
	PlatformType PlatformType `protobuf:"varint,2,opt,name=platform_type,json=platformType,enum=main.PlatformType" json:"platform_type,omitempty"`
	// The threat entry type matching this threat.
	ThreatEntryType ThreatEntryType `protobuf:"varint,6,opt,name=threat_entry_type,json=threatEntryType,enum=main.ThreatEntryType" json:"threat_entry_type,omitempty"`
	// The threat matching this threat.
	Threat *ThreatEntry `protobuf:"bytes,3,opt,name=threat" json:"threat,omitempty"`
	// Optional metadata associated with this threat.
	ThreatEntryMetadata *ThreatEntryMetadata `protobuf:"bytes,4,opt,name=threat_entry_metadata,json=threatEntryMetadata" json:"threat_entry_metadata,omitempty"`
	// The cache lifetime for the returned match. Clients must not cache this
	// response for more than this duration to avoid false positives.
	CacheDuration *google_protobuf.Duration `protobuf:"bytes,5,opt,name=cache_duration,json=cacheDuration" json:"cache_duration,omitempty"`
}

func (m *ThreatMatch) Reset()                    { *m = ThreatMatch{} }
func (m *ThreatMatch) String() string            { return proto.CompactTextString(m) }
func (*ThreatMatch) ProtoMessage()               {}
func (*ThreatMatch) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ThreatMatch) GetThreatType() ThreatType {
	if m != nil {
		return m.ThreatType
	}
	return ThreatType_THREAT_TYPE_UNSPECIFIED
}

func (m *ThreatMatch) GetPlatformType() PlatformType {
	if m != nil {
		return m.PlatformType
	}
	return PlatformType_PLATFORM_TYPE_UNSPECIFIED
}

func (m *ThreatMatch) GetThreatEntryType() ThreatEntryType {
	if m != nil {
		return m.ThreatEntryType
	}
	return ThreatEntryType_THREAT_ENTRY_TYPE_UNSPECIFIED
}

func (m *ThreatMatch) GetThreat() *ThreatEntry {
	if m != nil {
		return m.Threat
	}
	return nil
}

func (m *ThreatMatch) GetThreatEntryMetadata() *ThreatEntryMetadata {
	if m != nil {
		return m.ThreatEntryMetadata
	}
	return nil
}

func (m *ThreatMatch) GetCacheDuration() *google_protobuf.Duration {
	if m != nil {
		return m.CacheDuration
	}
	return nil
}

// Request to check entries against lists.
type FindThreatMatchesRequest struct {
	// The client metadata.
	Client *ClientInfo `protobuf:"bytes,1,opt,name=client" json:"client,omitempty"`
	// The lists and entries to be checked for matches.
	ThreatInfo *ThreatInfo `protobuf:"bytes,2,opt,name=threat_info,json=threatInfo" json:"threat_info,omitempty"`
}

func (m *FindThreatMatchesRequest) Reset()                    { *m = FindThreatMatchesRequest{} }
func (m *FindThreatMatchesRequest) String() string            { return proto.CompactTextString(m) }
func (*FindThreatMatchesRequest) ProtoMessage()               {}
func (*FindThreatMatchesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *FindThreatMatchesRequest) GetClient() *ClientInfo {
	if m != nil {
		return m.Client
	}
	return nil
}

func (m *FindThreatMatchesRequest) GetThreatInfo() *ThreatInfo {
	if m != nil {
		return m.ThreatInfo
	}
	return nil
}

// Response type for requests to find threat matches.
type FindThreatMatchesResponse struct {
	// The threat list matches.
	Matches []*ThreatMatch `protobuf:"bytes,1,rep,name=matches" json:"matches,omitempty"`
}

func (m *FindThreatMatchesResponse) Reset()                    { *m = FindThreatMatchesResponse{} }
func (m *FindThreatMatchesResponse) String() string            { return proto.CompactTextString(m) }
func (*FindThreatMatchesResponse) ProtoMessage()               {}
func (*FindThreatMatchesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *FindThreatMatchesResponse) GetMatches() []*ThreatMatch {
	if m != nil {
		return m.Matches
	}
	return nil
}

// Describes a Safe Browsing API update request. Clients can request updates for
// multiple lists in a single request.
// NOTE: Field index 2 is unused.
type FetchThreatListUpdatesRequest struct {
	// The client metadata.
	Client *ClientInfo `protobuf:"bytes,1,opt,name=client" json:"client,omitempty"`
	// The requested threat list updates.
	ListUpdateRequests []*FetchThreatListUpdatesRequest_ListUpdateRequest `protobuf:"bytes,3,rep,name=list_update_requests,json=listUpdateRequests" json:"list_update_requests,omitempty"`
}

func (m *FetchThreatListUpdatesRequest) Reset()                    { *m = FetchThreatListUpdatesRequest{} }
func (m *FetchThreatListUpdatesRequest) String() string            { return proto.CompactTextString(m) }
func (*FetchThreatListUpdatesRequest) ProtoMessage()               {}
func (*FetchThreatListUpdatesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *FetchThreatListUpdatesRequest) GetClient() *ClientInfo {
	if m != nil {
		return m.Client
	}
	return nil
}

func (m *FetchThreatListUpdatesRequest) GetListUpdateRequests() []*FetchThreatListUpdatesRequest_ListUpdateRequest {
	if m != nil {
		return m.ListUpdateRequests
	}
	return nil
}

// A single list update request.
type FetchThreatListUpdatesRequest_ListUpdateRequest struct {
	// The type of threat posed by entries present in the list.
	ThreatType ThreatType `protobuf:"varint,1,opt,name=threat_type,json=threatType,enum=main.ThreatType" json:"threat_type,omitempty"`
	// The type of platform at risk by entries present in the list.
	PlatformType PlatformType `protobuf:"varint,2,opt,name=platform_type,json=platformType,enum=main.PlatformType" json:"platform_type,omitempty"`
	// The types of entries present in the list.
	ThreatEntryType ThreatEntryType `protobuf:"varint,5,opt,name=threat_entry_type,json=threatEntryType,enum=main.ThreatEntryType" json:"threat_entry_type,omitempty"`
	// The current state of the client for the requested list (the encrypted
	// ClientState that was sent to the client from the previous update
	// request).
	State []byte `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
	// The constraints associated with this request.
	Constraints *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints `protobuf:"bytes,4,opt,name=constraints" json:"constraints,omitempty"`
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest) Reset() {
	*m = FetchThreatListUpdatesRequest_ListUpdateRequest{}
}
func (m *FetchThreatListUpdatesRequest_ListUpdateRequest) String() string {
	return proto.CompactTextString(m)
}
func (*FetchThreatListUpdatesRequest_ListUpdateRequest) ProtoMessage() {}
func (*FetchThreatListUpdatesRequest_ListUpdateRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0}
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest) GetThreatType() ThreatType {
	if m != nil {
		return m.ThreatType
	}
	return ThreatType_THREAT_TYPE_UNSPECIFIED
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest) GetPlatformType() PlatformType {
	if m != nil {
		return m.PlatformType
	}
	return PlatformType_PLATFORM_TYPE_UNSPECIFIED
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest) GetThreatEntryType() ThreatEntryType {
	if m != nil {
		return m.ThreatEntryType
	}
	return ThreatEntryType_THREAT_ENTRY_TYPE_UNSPECIFIED
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest) GetConstraints() *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints {
	if m != nil {
		return m.Constraints
	}
	return nil
}

// The constraints for this update.
type FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints struct {
	// The maximum size in number of entries. The update will not contain more
	// entries than this value.  This should be a power of 2 between 2**10 and
	// 2**20.  If zero, no update size limit is set.
	MaxUpdateEntries int32 `protobuf:"varint,1,opt,name=max_update_entries,json=maxUpdateEntries" json:"max_update_entries,omitempty"`
	// Sets the maximum number of entries that the client is willing to have
	// in the local database. This should be a power of 2 between 2**10 and
	// 2**20. If zero, no database size limit is set.
	MaxDatabaseEntries int32 `protobuf:"varint,2,opt,name=max_database_entries,json=maxDatabaseEntries" json:"max_database_entries,omitempty"`
	// Requests the list for a specific geographic location. If not set the
	// server may pick that value based on the user's IP address. Expects ISO
	// 3166-1 alpha-2 format.
	Region string `protobuf:"bytes,3,opt,name=region" json:"region,omitempty"`
	// The compression types supported by the client.
	SupportedCompressions []CompressionType `protobuf:"varint,4,rep,packed,name=supported_compressions,json=supportedCompressions,enum=main.CompressionType" json:"supported_compressions,omitempty"`
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) Reset() {
	*m = FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints{}
}
func (m *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) String() string {
	return proto.CompactTextString(m)
}
func (*FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) ProtoMessage() {}
func (*FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{4, 0, 0}
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) GetMaxUpdateEntries() int32 {
	if m != nil {
		return m.MaxUpdateEntries
	}
	return 0
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) GetMaxDatabaseEntries() int32 {
	if m != nil {
		return m.MaxDatabaseEntries
	}
	return 0
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) GetRegion() string {
	if m != nil {
		return m.Region
	}
	return ""
}

func (m *FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints) GetSupportedCompressions() []CompressionType {
	if m != nil {
		return m.SupportedCompressions
	}
	return nil
}

// Response type for threat list update requests.
type FetchThreatListUpdatesResponse struct {
	// The list updates requested by the clients.
	ListUpdateResponses []*FetchThreatListUpdatesResponse_ListUpdateResponse `protobuf:"bytes,1,rep,name=list_update_responses,json=listUpdateResponses" json:"list_update_responses,omitempty"`
	// The minimum duration the client must wait before issuing any update
	// request. If this field is not set clients may update as soon as they want.
	MinimumWaitDuration *google_protobuf.Duration `protobuf:"bytes,2,opt,name=minimum_wait_duration,json=minimumWaitDuration" json:"minimum_wait_duration,omitempty"`
}

func (m *FetchThreatListUpdatesResponse) Reset()                    { *m = FetchThreatListUpdatesResponse{} }
func (m *FetchThreatListUpdatesResponse) String() string            { return proto.CompactTextString(m) }
func (*FetchThreatListUpdatesResponse) ProtoMessage()               {}
func (*FetchThreatListUpdatesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *FetchThreatListUpdatesResponse) GetListUpdateResponses() []*FetchThreatListUpdatesResponse_ListUpdateResponse {
	if m != nil {
		return m.ListUpdateResponses
	}
	return nil
}

func (m *FetchThreatListUpdatesResponse) GetMinimumWaitDuration() *google_protobuf.Duration {
	if m != nil {
		return m.MinimumWaitDuration
	}
	return nil
}

// An update to an individual list.
type FetchThreatListUpdatesResponse_ListUpdateResponse struct {
	// The threat type for which data is returned.
	ThreatType ThreatType `protobuf:"varint,1,opt,name=threat_type,json=threatType,enum=main.ThreatType" json:"threat_type,omitempty"`
	// The format of the threats.
	ThreatEntryType ThreatEntryType `protobuf:"varint,2,opt,name=threat_entry_type,json=threatEntryType,enum=main.ThreatEntryType" json:"threat_entry_type,omitempty"`
	// The platform type for which data is returned.
	PlatformType PlatformType `protobuf:"varint,3,opt,name=platform_type,json=platformType,enum=main.PlatformType" json:"platform_type,omitempty"`
	// The type of response. This may indicate that an action is required by the
	// client when the response is received.
	ResponseType FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType `protobuf:"varint,4,opt,name=response_type,json=responseType,enum=main.FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType" json:"response_type,omitempty"`
	// A set of entries to add to a local threat type's list. Repeated to allow
	// for a combination of compressed and raw data to be sent in a single
	// response.
	Additions []*ThreatEntrySet `protobuf:"bytes,5,rep,name=additions" json:"additions,omitempty"`
	// A set of entries to remove from a local threat type's list. Repeated for
	// the same reason as above.
	Removals []*ThreatEntrySet `protobuf:"bytes,6,rep,name=removals" json:"removals,omitempty"`
	// The new client state, in encrypted format. Opaque to clients.
	NewClientState []byte `protobuf:"bytes,7,opt,name=new_client_state,json=newClientState,proto3" json:"new_client_state,omitempty"`
	// The expected SHA256 hash of the client state; that is, of the sorted list
	// of all hashes present in the database after applying the provided update.
	// If the client state doesn't match the expected state, the client must
	// disregard this update and retry later.
	Checksum *Checksum `protobuf:"bytes,8,opt,name=checksum" json:"checksum,omitempty"`
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) Reset() {
	*m = FetchThreatListUpdatesResponse_ListUpdateResponse{}
}
func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) String() string {
	return proto.CompactTextString(m)
}
func (*FetchThreatListUpdatesResponse_ListUpdateResponse) ProtoMessage() {}
func (*FetchThreatListUpdatesResponse_ListUpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{5, 0}
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) GetThreatType() ThreatType {
	if m != nil {
		return m.ThreatType
	}
	return ThreatType_THREAT_TYPE_UNSPECIFIED
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) GetThreatEntryType() ThreatEntryType {
	if m != nil {
		return m.ThreatEntryType
	}
	return ThreatEntryType_THREAT_ENTRY_TYPE_UNSPECIFIED
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) GetPlatformType() PlatformType {
	if m != nil {
		return m.PlatformType
	}
	return PlatformType_PLATFORM_TYPE_UNSPECIFIED
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) GetResponseType() FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType {
	if m != nil {
		return m.ResponseType
	}
	return FetchThreatListUpdatesResponse_ListUpdateResponse_RESPONSE_TYPE_UNSPECIFIED
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) GetAdditions() []*ThreatEntrySet {
	if m != nil {
		return m.Additions
	}
	return nil
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) GetRemovals() []*ThreatEntrySet {
	if m != nil {
		return m.Removals
	}
	return nil
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) GetNewClientState() []byte {
	if m != nil {
		return m.NewClientState
	}
	return nil
}

func (m *FetchThreatListUpdatesResponse_ListUpdateResponse) GetChecksum() *Checksum {
	if m != nil {
		return m.Checksum
	}
	return nil
}

// Request to return full hashes matched by the provided hash prefixes.
type FindFullHashesRequest struct {
	// The client metadata.
	Client *ClientInfo `protobuf:"bytes,1,opt,name=client" json:"client,omitempty"`
	// The current client states for each of the client's local threat lists.
	ClientStates [][]byte `protobuf:"bytes,2,rep,name=client_states,json=clientStates,proto3" json:"client_states,omitempty"`
	// The lists and hashes to be checked.
	ThreatInfo *ThreatInfo `protobuf:"bytes,3,opt,name=threat_info,json=threatInfo" json:"threat_info,omitempty"`
}

func (m *FindFullHashesRequest) Reset()                    { *m = FindFullHashesRequest{} }
func (m *FindFullHashesRequest) String() string            { return proto.CompactTextString(m) }
func (*FindFullHashesRequest) ProtoMessage()               {}
func (*FindFullHashesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *FindFullHashesRequest) GetClient() *ClientInfo {
	if m != nil {
		return m.Client
	}
	return nil
}

func (m *FindFullHashesRequest) GetClientStates() [][]byte {
	if m != nil {
		return m.ClientStates
	}
	return nil
}

func (m *FindFullHashesRequest) GetThreatInfo() *ThreatInfo {
	if m != nil {
		return m.ThreatInfo
	}
	return nil
}

// Response type for requests to find full hashes.
type FindFullHashesResponse struct {
	// The full hashes that matched the requested prefixes.
	Matches []*ThreatMatch `protobuf:"bytes,1,rep,name=matches" json:"matches,omitempty"`
	// The minimum duration the client must wait before issuing any find hashes
	// request. If this field is not set, clients can issue a request as soon as
	// they want.
	MinimumWaitDuration *google_protobuf.Duration `protobuf:"bytes,2,opt,name=minimum_wait_duration,json=minimumWaitDuration" json:"minimum_wait_duration,omitempty"`
	// For requested entities that did not match the threat list, how long to
	// cache the response.
	NegativeCacheDuration *google_protobuf.Duration `protobuf:"bytes,3,opt,name=negative_cache_duration,json=negativeCacheDuration" json:"negative_cache_duration,omitempty"`
}

func (m *FindFullHashesResponse) Reset()                    { *m = FindFullHashesResponse{} }
func (m *FindFullHashesResponse) String() string            { return proto.CompactTextString(m) }
func (*FindFullHashesResponse) ProtoMessage()               {}
func (*FindFullHashesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *FindFullHashesResponse) GetMatches() []*ThreatMatch {
	if m != nil {
		return m.Matches
	}
	return nil
}

func (m *FindFullHashesResponse) GetMinimumWaitDuration() *google_protobuf.Duration {
	if m != nil {
		return m.MinimumWaitDuration
	}
	return nil
}

func (m *FindFullHashesResponse) GetNegativeCacheDuration() *google_protobuf.Duration {
	if m != nil {
		return m.NegativeCacheDuration
	}
	return nil
}

// The client metadata associated with Safe Browsing API requests.
type ClientInfo struct {
	// A client ID that (hopefully) uniquely identifies the client implementation
	// of the Safe Browsing API.
	ClientId string `protobuf:"bytes,1,opt,name=client_id,json=clientId" json:"client_id,omitempty"`
	// The version of the client implementation.
	ClientVersion string `protobuf:"bytes,2,opt,name=client_version,json=clientVersion" json:"client_version,omitempty"`
}

func (m *ClientInfo) Reset()                    { *m = ClientInfo{} }
func (m *ClientInfo) String() string            { return proto.CompactTextString(m) }
func (*ClientInfo) ProtoMessage()               {}
func (*ClientInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ClientInfo) GetClientId() string {
	if m != nil {
		return m.ClientId
	}
	return ""
}

func (m *ClientInfo) GetClientVersion() string {
	if m != nil {
		return m.ClientVersion
	}
	return ""
}

// The expected state of a client's local database.
type Checksum struct {
	// The SHA256 hash of the client state; that is, of the sorted list of all
	// hashes present in the database.
	Sha256 []byte `protobuf:"bytes,1,opt,name=sha256,proto3" json:"sha256,omitempty"`
}

func (m *Checksum) Reset()                    { *m = Checksum{} }
func (m *Checksum) String() string            { return proto.CompactTextString(m) }
func (*Checksum) ProtoMessage()               {}
func (*Checksum) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Checksum) GetSha256() []byte {
	if m != nil {
		return m.Sha256
	}
	return nil
}

// An individual threat; for example, a malicious URL or its hash
// representation. Only one of these fields should be set.
type ThreatEntry struct {
	// A hash prefix, consisting of the most significant 4-32 bytes of a SHA256
	// hash.
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// A URL.
	Url string `protobuf:"bytes,2,opt,name=url" json:"url,omitempty"`
}

func (m *ThreatEntry) Reset()                    { *m = ThreatEntry{} }
func (m *ThreatEntry) String() string            { return proto.CompactTextString(m) }
func (*ThreatEntry) ProtoMessage()               {}
func (*ThreatEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ThreatEntry) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *ThreatEntry) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// A set of threats that should be added or removed from a client's local
// database.
type ThreatEntrySet struct {
	// The compression type for the entries in this set.
	CompressionType CompressionType `protobuf:"varint,1,opt,name=compression_type,json=compressionType,enum=main.CompressionType" json:"compression_type,omitempty"`
	// The raw SHA256-formatted entries.
	RawHashes *RawHashes `protobuf:"bytes,2,opt,name=raw_hashes,json=rawHashes" json:"raw_hashes,omitempty"`
	// The raw removal indices for a local list.
	RawIndices *RawIndices `protobuf:"bytes,3,opt,name=raw_indices,json=rawIndices" json:"raw_indices,omitempty"`
	// The encoded 4-byte prefixes of SHA256-formatted entries, using a
	// Golomb-Rice encoding.
	RiceHashes *RiceDeltaEncoding `protobuf:"bytes,4,opt,name=rice_hashes,json=riceHashes" json:"rice_hashes,omitempty"`
	// The encoded local, lexicographically-sorted list indices, using a
	// Golomb-Rice encoding. Used for sending compressed removal indices.
	RiceIndices *RiceDeltaEncoding `protobuf:"bytes,5,opt,name=rice_indices,json=riceIndices" json:"rice_indices,omitempty"`
}

func (m *ThreatEntrySet) Reset()                    { *m = ThreatEntrySet{} }
func (m *ThreatEntrySet) String() string            { return proto.CompactTextString(m) }
func (*ThreatEntrySet) ProtoMessage()               {}
func (*ThreatEntrySet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ThreatEntrySet) GetCompressionType() CompressionType {
	if m != nil {
		return m.CompressionType
	}
	return CompressionType_COMPRESSION_TYPE_UNSPECIFIED
}

func (m *ThreatEntrySet) GetRawHashes() *RawHashes {
	if m != nil {
		return m.RawHashes
	}
	return nil
}

func (m *ThreatEntrySet) GetRawIndices() *RawIndices {
	if m != nil {
		return m.RawIndices
	}
	return nil
}

func (m *ThreatEntrySet) GetRiceHashes() *RiceDeltaEncoding {
	if m != nil {
		return m.RiceHashes
	}
	return nil
}

func (m *ThreatEntrySet) GetRiceIndices() *RiceDeltaEncoding {
	if m != nil {
		return m.RiceIndices
	}
	return nil
}

// A set of raw indices to remove from a local list.
type RawIndices struct {
	// The indices to remove from a lexicographically-sorted local list.
	Indices []int32 `protobuf:"varint,1,rep,packed,name=indices" json:"indices,omitempty"`
}

func (m *RawIndices) Reset()                    { *m = RawIndices{} }
func (m *RawIndices) String() string            { return proto.CompactTextString(m) }
func (*RawIndices) ProtoMessage()               {}
func (*RawIndices) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *RawIndices) GetIndices() []int32 {
	if m != nil {
		return m.Indices
	}
	return nil
}

// The uncompressed threat entries in hash format of a particular prefix length.
// Hashes can be anywhere from 4 to 32 bytes in size. A large majority are 4
// bytes, but some hashes are lengthened if they collide with the hash of a
// popular URL.
//
// Used for sending ThreatEntrySet to clients that do not support compression,
// or when sending non-4-byte hashes to clients that do support compression.
type RawHashes struct {
	// The number of bytes for each prefix encoded below.  This field can be
	// anywhere from 4 (shortest prefix) to 32 (full SHA256 hash).
	PrefixSize int32 `protobuf:"varint,1,opt,name=prefix_size,json=prefixSize" json:"prefix_size,omitempty"`
	// The hashes, all concatenated into one long string.  Each hash has a prefix
	// size of |prefix_size| above. Hashes are sorted in lexicographic order.
	RawHashes []byte `protobuf:"bytes,2,opt,name=raw_hashes,json=rawHashes,proto3" json:"raw_hashes,omitempty"`
}

func (m *RawHashes) Reset()                    { *m = RawHashes{} }
func (m *RawHashes) String() string            { return proto.CompactTextString(m) }
func (*RawHashes) ProtoMessage()               {}
func (*RawHashes) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *RawHashes) GetPrefixSize() int32 {
	if m != nil {
		return m.PrefixSize
	}
	return 0
}

func (m *RawHashes) GetRawHashes() []byte {
	if m != nil {
		return m.RawHashes
	}
	return nil
}

// The Rice-Golomb encoded data. Used for sending compressed 4-byte hashes or
// compressed removal indices.
type RiceDeltaEncoding struct {
	// The offset of the first entry in the encoded data, or, if only a single
	// integer was encoded, that single integer's value.
	FirstValue int64 `protobuf:"varint,1,opt,name=first_value,json=firstValue" json:"first_value,omitempty"`
	// The Golomb-Rice parameter which is a number between 2 and 28. This field
	// is missing (that is, zero) if num_entries is zero.
	RiceParameter int32 `protobuf:"varint,2,opt,name=rice_parameter,json=riceParameter" json:"rice_parameter,omitempty"`
	// The number of entries that are delta encoded in the encoded data. If only a
	// single integer was encoded, this will be zero and the single value will be
	// stored in first_value.
	NumEntries int32 `protobuf:"varint,3,opt,name=num_entries,json=numEntries" json:"num_entries,omitempty"`
	// The encoded deltas that are encoded using the Golomb-Rice coder.
	EncodedData []byte `protobuf:"bytes,4,opt,name=encoded_data,json=encodedData,proto3" json:"encoded_data,omitempty"`
}

func (m *RiceDeltaEncoding) Reset()                    { *m = RiceDeltaEncoding{} }
func (m *RiceDeltaEncoding) String() string            { return proto.CompactTextString(m) }
func (*RiceDeltaEncoding) ProtoMessage()               {}
func (*RiceDeltaEncoding) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *RiceDeltaEncoding) GetFirstValue() int64 {
	if m != nil {
		return m.FirstValue
	}
	return 0
}

func (m *RiceDeltaEncoding) GetRiceParameter() int32 {
	if m != nil {
		return m.RiceParameter
	}
	return 0
}

func (m *RiceDeltaEncoding) GetNumEntries() int32 {
	if m != nil {
		return m.NumEntries
	}
	return 0
}

func (m *RiceDeltaEncoding) GetEncodedData() []byte {
	if m != nil {
		return m.EncodedData
	}
	return nil
}

// The metadata associated with a specific threat entry. The client is expected
// to know the metadata key/value pairs associated with each threat type.
type ThreatEntryMetadata struct {
	// The metadata entries.
	Entries []*ThreatEntryMetadata_MetadataEntry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
}

func (m *ThreatEntryMetadata) Reset()                    { *m = ThreatEntryMetadata{} }
func (m *ThreatEntryMetadata) String() string            { return proto.CompactTextString(m) }
func (*ThreatEntryMetadata) ProtoMessage()               {}
func (*ThreatEntryMetadata) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *ThreatEntryMetadata) GetEntries() []*ThreatEntryMetadata_MetadataEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// A single metadata entry.
type ThreatEntryMetadata_MetadataEntry struct {
	// The metadata entry key.
	Key []byte `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	// The metadata entry value.
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *ThreatEntryMetadata_MetadataEntry) Reset()         { *m = ThreatEntryMetadata_MetadataEntry{} }
func (m *ThreatEntryMetadata_MetadataEntry) String() string { return proto.CompactTextString(m) }
func (*ThreatEntryMetadata_MetadataEntry) ProtoMessage()    {}
func (*ThreatEntryMetadata_MetadataEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{15, 0}
}

func (m *ThreatEntryMetadata_MetadataEntry) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *ThreatEntryMetadata_MetadataEntry) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// Describes an individual threat list. A list is defined by three parameters:
// the type of threat posed, the type of platform targeted by the threat, and
// the type of entries in the list.
type ThreatListDescriptor struct {
	// The threat type posed by the list's entries.
	ThreatType ThreatType `protobuf:"varint,1,opt,name=threat_type,json=threatType,enum=main.ThreatType" json:"threat_type,omitempty"`
	// The platform type targeted by the list's entries.
	PlatformType PlatformType `protobuf:"varint,2,opt,name=platform_type,json=platformType,enum=main.PlatformType" json:"platform_type,omitempty"`
	// The entry types contained in the list.
	ThreatEntryType ThreatEntryType `protobuf:"varint,3,opt,name=threat_entry_type,json=threatEntryType,enum=main.ThreatEntryType" json:"threat_entry_type,omitempty"`
}

func (m *ThreatListDescriptor) Reset()                    { *m = ThreatListDescriptor{} }
func (m *ThreatListDescriptor) String() string            { return proto.CompactTextString(m) }
func (*ThreatListDescriptor) ProtoMessage()               {}
func (*ThreatListDescriptor) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ThreatListDescriptor) GetThreatType() ThreatType {
	if m != nil {
		return m.ThreatType
	}
	return ThreatType_THREAT_TYPE_UNSPECIFIED
}

func (m *ThreatListDescriptor) GetPlatformType() PlatformType {
	if m != nil {
		return m.PlatformType
	}
	return PlatformType_PLATFORM_TYPE_UNSPECIFIED
}

func (m *ThreatListDescriptor) GetThreatEntryType() ThreatEntryType {
	if m != nil {
		return m.ThreatEntryType
	}
	return ThreatEntryType_THREAT_ENTRY_TYPE_UNSPECIFIED
}

// A collection of lists available for download by the client.
type ListThreatListsResponse struct {
	// The lists available for download by the client.
	ThreatLists []*ThreatListDescriptor `protobuf:"bytes,1,rep,name=threat_lists,json=threatLists" json:"threat_lists,omitempty"`
}

func (m *ListThreatListsResponse) Reset()                    { *m = ListThreatListsResponse{} }
func (m *ListThreatListsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListThreatListsResponse) ProtoMessage()               {}
func (*ListThreatListsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ListThreatListsResponse) GetThreatLists() []*ThreatListDescriptor {
	if m != nil {
		return m.ThreatLists
	}
	return nil
}

func init() {
	proto.RegisterType((*ThreatInfo)(nil), "main.ThreatInfo")
	proto.RegisterType((*ThreatMatch)(nil), "main.ThreatMatch")
	proto.RegisterType((*FindThreatMatchesRequest)(nil), "main.FindThreatMatchesRequest")
	proto.RegisterType((*FindThreatMatchesResponse)(nil), "main.FindThreatMatchesResponse")
	proto.RegisterType((*FetchThreatListUpdatesRequest)(nil), "main.FetchThreatListUpdatesRequest")
	proto.RegisterType((*FetchThreatListUpdatesRequest_ListUpdateRequest)(nil), "main.FetchThreatListUpdatesRequest.ListUpdateRequest")
	proto.RegisterType((*FetchThreatListUpdatesRequest_ListUpdateRequest_Constraints)(nil), "main.FetchThreatListUpdatesRequest.ListUpdateRequest.Constraints")
	proto.RegisterType((*FetchThreatListUpdatesResponse)(nil), "main.FetchThreatListUpdatesResponse")
	proto.RegisterType((*FetchThreatListUpdatesResponse_ListUpdateResponse)(nil), "main.FetchThreatListUpdatesResponse.ListUpdateResponse")
	proto.RegisterType((*FindFullHashesRequest)(nil), "main.FindFullHashesRequest")
	proto.RegisterType((*FindFullHashesResponse)(nil), "main.FindFullHashesResponse")
	proto.RegisterType((*ClientInfo)(nil), "main.ClientInfo")
	proto.RegisterType((*Checksum)(nil), "main.Checksum")
	proto.RegisterType((*ThreatEntry)(nil), "main.ThreatEntry")
	proto.RegisterType((*ThreatEntrySet)(nil), "main.ThreatEntrySet")
	proto.RegisterType((*RawIndices)(nil), "main.RawIndices")
	proto.RegisterType((*RawHashes)(nil), "main.RawHashes")
	proto.RegisterType((*RiceDeltaEncoding)(nil), "main.RiceDeltaEncoding")
	proto.RegisterType((*ThreatEntryMetadata)(nil), "main.ThreatEntryMetadata")
	proto.RegisterType((*ThreatEntryMetadata_MetadataEntry)(nil), "main.ThreatEntryMetadata.MetadataEntry")
	proto.RegisterType((*ThreatListDescriptor)(nil), "main.ThreatListDescriptor")
	proto.RegisterType((*ListThreatListsResponse)(nil), "main.ListThreatListsResponse")
	proto.RegisterEnum("main.ThreatType", ThreatType_name, ThreatType_value)
	proto.RegisterEnum("main.PlatformType", PlatformType_name, PlatformType_value)
	proto.RegisterEnum("main.CompressionType", CompressionType_name, CompressionType_value)
	proto.RegisterEnum("main.ThreatEntryType", ThreatEntryType_name, ThreatEntryType_value)
	proto.RegisterEnum("main.FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType", FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_name, FetchThreatListUpdatesResponse_ListUpdateResponse_ResponseType_value)
}

func init() { proto.RegisterFile("safebrowsing.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1616 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0xdd, 0x8e, 0x1b, 0x49,
	0x15, 0xa6, 0xfd, 0x37, 0xf6, 0xf1, 0xcf, 0xf4, 0x54, 0x66, 0x12, 0x67, 0x96, 0xec, 0xce, 0xf6,
	0x0a, 0x08, 0x03, 0xf2, 0x2e, 0x89, 0x96, 0x2c, 0x48, 0x48, 0xdb, 0xd8, 0xed, 0x4c, 0x0b, 0xbb,
	0x6d, 0xca, 0xf6, 0x4e, 0x22, 0x2e, 0x5a, 0x9d, 0x76, 0xcd, 0xb8, 0x15, 0xbb, 0xdb, 0x74, 0x95,
	0xe3, 0x64, 0x1f, 0x81, 0x3b, 0x84, 0xb8, 0xe0, 0x02, 0xf1, 0x00, 0xbc, 0x03, 0x77, 0x48, 0xdc,
	0xf3, 0x10, 0xbc, 0x02, 0x12, 0x37, 0xa8, 0x7e, 0xda, 0x6e, 0xff, 0x4c, 0x76, 0x33, 0x5a, 0x29,
	0x77, 0x55, 0x5f, 0x9d, 0x9f, 0x3e, 0xa7, 0xbe, 0x3a, 0xe7, 0x34, 0x20, 0xea, 0x5d, 0x91, 0x17,
	0x71, 0xb4, 0xa4, 0x41, 0x78, 0xdd, 0x98, 0xc7, 0x11, 0x8b, 0x50, 0x6e, 0xe6, 0x05, 0xe1, 0xe9,
	0x87, 0xd7, 0x51, 0x74, 0x3d, 0x25, 0x9f, 0x0a, 0xec, 0xc5, 0xe2, 0xea, 0xd3, 0xf1, 0x22, 0xf6,
	0x58, 0x10, 0x85, 0x52, 0xca, 0xf8, 0x9f, 0x06, 0x30, 0x9c, 0xc4, 0xc4, 0x63, 0x76, 0x78, 0x15,
	0xa1, 0xc7, 0x50, 0x61, 0x62, 0xe7, 0xb2, 0x37, 0x73, 0x42, 0xeb, 0xda, 0x59, 0xf6, 0x61, 0xed,
	0x91, 0xde, 0xe0, 0xb6, 0x1a, 0x52, 0x6e, 0xf8, 0x66, 0x4e, 0x70, 0x99, 0xad, 0xd6, 0x14, 0xfd,
	0x02, 0x6a, 0xf3, 0xa9, 0xc7, 0xae, 0xa2, 0x78, 0xa6, 0xd4, 0x32, 0x42, 0x0d, 0x49, 0xb5, 0xbe,
	0x3a, 0x13, 0x8a, 0xd5, 0x79, 0x6a, 0x47, 0x51, 0x13, 0x90, 0xf2, 0x47, 0x42, 0x16, 0xbf, 0x51,
	0xea, 0x39, 0xa1, 0x7e, 0x92, 0xf6, 0x6a, 0xf1, 0x63, 0x61, 0x41, 0x67, 0x9b, 0x00, 0x45, 0x5f,
	0x40, 0x2d, 0x65, 0x24, 0x20, 0xb4, 0x9e, 0x3d, 0xcb, 0x3e, 0x2c, 0x3f, 0x3a, 0xda, 0x31, 0x80,
	0xab, 0x6b, 0xe5, 0x80, 0x50, 0xe3, 0xbf, 0x19, 0x28, 0xcb, 0xe3, 0xae, 0xc7, 0xfc, 0x09, 0xfa,
	0x19, 0x94, 0x53, 0xe1, 0xd7, 0xb5, 0x33, 0x6d, 0x6f, 0xf4, 0xb0, 0x8e, 0x1e, 0x3d, 0x81, 0xea,
	0x46, 0xf0, 0xf5, 0x8c, 0x50, 0xda, 0x17, 0x7b, 0x25, 0x1d, 0x3b, 0x32, 0xe1, 0x68, 0x27, 0xf4,
	0x7a, 0x41, 0x28, 0xdf, 0x10, 0xf9, 0xe1, 0x56, 0xe4, 0xe8, 0xc7, 0x50, 0x90, 0x50, 0x3d, 0x7b,
	0xa6, 0xed, 0x0f, 0x58, 0x09, 0xa0, 0x2e, 0x9c, 0x6c, 0x78, 0x9b, 0x11, 0xe6, 0x8d, 0x3d, 0xe6,
	0xd5, 0x73, 0x42, 0xf3, 0xfe, 0x8e, 0x66, 0x57, 0x09, 0xe0, 0x3b, 0x6c, 0x17, 0x44, 0x5f, 0x42,
	0xcd, 0xf7, 0xfc, 0x09, 0x71, 0x13, 0x3a, 0xd5, 0xf3, 0xca, 0x8e, 0xe4, 0x5b, 0x23, 0xe1, 0x5b,
	0xa3, 0xa5, 0x04, 0x70, 0x55, 0x28, 0x24, 0x5b, 0x63, 0x09, 0xf5, 0x76, 0x10, 0x8e, 0x53, 0xd9,
	0x27, 0x14, 0x93, 0xdf, 0x2f, 0x08, 0x65, 0xe8, 0x21, 0x14, 0xfc, 0x69, 0x40, 0x42, 0x26, 0x6e,
	0xa0, 0x9c, 0xdc, 0x40, 0x53, 0x60, 0x9c, 0xa7, 0x58, 0x9d, 0xa7, 0x2e, 0x2c, 0x08, 0xaf, 0x22,
	0x91, 0xfb, 0xf2, 0xe6, 0x85, 0x09, 0x71, 0x75, 0x61, 0x7c, 0x6d, 0x5c, 0xc0, 0xfd, 0x3d, 0x8e,
	0xe9, 0x3c, 0x0a, 0x29, 0x41, 0x3f, 0x81, 0x83, 0x99, 0x84, 0x04, 0xf5, 0xb7, 0x52, 0x2a, 0xa4,
	0x71, 0x22, 0x61, 0xfc, 0x2b, 0x0f, 0x0f, 0xda, 0x84, 0xf9, 0x13, 0x79, 0xda, 0x09, 0x28, 0x1b,
	0xcd, 0xc7, 0x1e, 0xbb, 0x4d, 0x20, 0xd7, 0x70, 0x3c, 0x0d, 0x28, 0x73, 0x17, 0xc2, 0x80, 0x1b,
	0x4b, 0x03, 0x09, 0x93, 0x3f, 0x97, 0x7a, 0x6f, 0x75, 0xd6, 0x58, 0x43, 0x0a, 0xc1, 0x68, 0xba,
	0x0d, 0xd1, 0xd3, 0x3f, 0xe5, 0xe0, 0x68, 0x47, 0xf2, 0xfd, 0x13, 0x3f, 0xff, 0x4e, 0xc4, 0x3f,
	0x86, 0x3c, 0x65, 0x1e, 0x23, 0x82, 0xf7, 0x15, 0x2c, 0x37, 0xc8, 0x87, 0xb2, 0x1f, 0x85, 0x94,
	0xc5, 0x5e, 0x10, 0x32, 0xaa, 0x98, 0x6d, 0xde, 0x2a, 0x75, 0x8d, 0xe6, 0xda, 0x10, 0x4e, 0x5b,
	0x3d, 0xfd, 0xb7, 0x06, 0xe5, 0xd4, 0x21, 0xfa, 0x29, 0xa0, 0x99, 0xf7, 0x3a, 0xb9, 0xb7, 0xa4,
	0x00, 0xf1, 0x04, 0xe6, 0xb1, 0x3e, 0xf3, 0x5e, 0x4b, 0xb3, 0xaa, 0xe0, 0xa0, 0xcf, 0xe0, 0x98,
	0x4b, 0xf3, 0x37, 0xf4, 0xc2, 0xa3, 0x6b, 0xf9, 0x8c, 0x90, 0xe7, 0x96, 0x5a, 0xea, 0x28, 0xd1,
	0xb8, 0x0b, 0x85, 0x98, 0x5c, 0xf3, 0x17, 0xc6, 0x63, 0x2d, 0x61, 0xb5, 0x43, 0x1d, 0xb8, 0x4b,
	0x17, 0xf3, 0x79, 0x14, 0x33, 0x32, 0x76, 0xfd, 0x68, 0x36, 0x8f, 0x09, 0xa5, 0x41, 0x14, 0x6e,
	0x55, 0xcf, 0xe6, 0xfa, 0x44, 0xa4, 0xf2, 0x64, 0xa5, 0x94, 0x3a, 0xa1, 0xc6, 0x5f, 0x0b, 0xf0,
	0xe1, 0x4d, 0x29, 0x52, 0x4f, 0xe3, 0x25, 0x9c, 0x6c, 0x32, 0x54, 0xe2, 0xc9, 0x43, 0x79, 0xf2,
	0xf6, 0x3c, 0x4b, 0xe1, 0x8d, 0x44, 0x4b, 0x08, 0xdf, 0x99, 0xee, 0x60, 0x94, 0x97, 0xab, 0x59,
	0x10, 0x06, 0xb3, 0xc5, 0xcc, 0x5d, 0x7a, 0x01, 0x5b, 0x97, 0x99, 0xcc, 0x37, 0x95, 0x99, 0x3b,
	0x4a, 0xef, 0xd2, 0x0b, 0x58, 0x02, 0x9e, 0xfe, 0x23, 0x07, 0x68, 0xd7, 0xf5, 0x6d, 0x58, 0xbf,
	0x97, 0xbc, 0x99, 0x77, 0x22, 0xef, 0xce, 0xc3, 0xc9, 0x7e, 0xcb, 0x87, 0x13, 0x40, 0x35, 0xc9,
	0xba, 0x54, 0xcc, 0x09, 0xc5, 0xd6, 0x2d, 0x33, 0xdf, 0x48, 0x16, 0xd2, 0x55, 0x9c, 0xda, 0xa1,
	0x47, 0x50, 0xf2, 0xc6, 0xe3, 0x80, 0x09, 0x42, 0xe5, 0xc5, 0x05, 0x1f, 0xef, 0x84, 0x37, 0x20,
	0x0c, 0xaf, 0xc5, 0xd0, 0x67, 0x50, 0x8c, 0xc9, 0x2c, 0x7a, 0xe5, 0x4d, 0x69, 0xbd, 0xf0, 0x16,
	0x95, 0x95, 0x14, 0x7a, 0x08, 0x7a, 0x48, 0x96, 0xae, 0x2c, 0x81, 0xae, 0x7c, 0xd1, 0x07, 0xe2,
	0x45, 0xd7, 0x42, 0xb2, 0x94, 0x55, 0x72, 0x20, 0x9e, 0xf6, 0x39, 0x14, 0xfd, 0x09, 0xf1, 0x5f,
	0xd2, 0xc5, 0xac, 0x5e, 0x14, 0x14, 0xa8, 0x29, 0x7e, 0x2b, 0x14, 0xaf, 0xce, 0x0d, 0x0c, 0x95,
	0x74, 0x64, 0xe8, 0x01, 0xdc, 0xc7, 0xd6, 0xa0, 0xdf, 0x73, 0x06, 0x96, 0x3b, 0x7c, 0xde, 0xb7,
	0xdc, 0x91, 0x33, 0xe8, 0x5b, 0x4d, 0xbb, 0x6d, 0x5b, 0x2d, 0xfd, 0x7b, 0x08, 0x41, 0xad, 0x6f,
	0xe2, 0xa1, 0x6d, 0x76, 0xdc, 0x51, 0xbf, 0x65, 0x0e, 0x2d, 0x5d, 0x43, 0x87, 0x50, 0x6e, 0x8f,
	0x3a, 0x2b, 0x20, 0x63, 0xfc, 0x45, 0x83, 0x13, 0xde, 0x35, 0xda, 0x8b, 0xe9, 0xf4, 0xc2, 0xa3,
	0xb7, 0xea, 0x55, 0x9f, 0x40, 0x35, 0x1d, 0xa9, 0x9c, 0x92, 0x2a, 0xb8, 0xe2, 0xaf, 0xe3, 0xa4,
	0xdb, 0x0d, 0x2d, 0xfb, 0x2d, 0x1a, 0xda, 0x7f, 0x34, 0xb8, 0xbb, 0xfd, 0x6d, 0xb7, 0x68, 0x67,
	0xdf, 0xf1, 0x9b, 0x43, 0xbf, 0x85, 0x7b, 0x21, 0xb9, 0xf6, 0x58, 0xf0, 0x8a, 0xb8, 0x5b, 0xb3,
	0x42, 0xf6, 0x9b, 0x0c, 0x9e, 0x24, 0x9a, 0xcd, 0x8d, 0x99, 0xa1, 0x0f, 0xb0, 0xce, 0x2b, 0xfa,
	0x00, 0x4a, 0x2a, 0x9f, 0xc1, 0x58, 0x24, 0xbf, 0x84, 0x8b, 0x12, 0xb0, 0xc7, 0xe8, 0x07, 0x50,
	0x53, 0x87, 0xaf, 0x48, 0x4c, 0x93, 0x28, 0x4a, 0x58, 0x5d, 0xc1, 0x57, 0x12, 0x34, 0x0c, 0x28,
	0x26, 0x0c, 0xe2, 0x95, 0x96, 0x4e, 0xbc, 0x47, 0x9f, 0xff, 0x5c, 0x18, 0xab, 0x60, 0xb5, 0x33,
	0x1e, 0x27, 0x33, 0xa2, 0x60, 0x30, 0x42, 0x90, 0x9b, 0x78, 0x74, 0xa2, 0x84, 0xc4, 0x1a, 0xe9,
	0x90, 0x5d, 0xc4, 0x53, 0xe5, 0x82, 0x2f, 0x8d, 0xbf, 0x67, 0xa0, 0xb6, 0xc9, 0x7b, 0xf4, 0x25,
	0xe8, 0xa9, 0x3a, 0x9d, 0x2e, 0x39, 0x37, 0xd4, 0xea, 0x43, 0x7f, 0x13, 0x40, 0x0d, 0x80, 0xd8,
	0x5b, 0xba, 0x13, 0x71, 0xc9, 0xea, 0x5a, 0x0e, 0xa5, 0x2e, 0xf6, 0x96, 0xea, 0xee, 0x4b, 0x71,
	0xb2, 0xe4, 0x64, 0xe2, 0xf2, 0x41, 0x38, 0x0e, 0x7c, 0x31, 0x15, 0xa7, 0xc8, 0x84, 0xbd, 0xa5,
	0x2d, 0x71, 0xcc, 0x8d, 0xaa, 0x35, 0xfa, 0x02, 0xca, 0x71, 0xe0, 0x93, 0xc4, 0x87, 0xec, 0xa1,
	0xf7, 0x94, 0x4a, 0xe0, 0x93, 0x16, 0x99, 0x32, 0xcf, 0x0a, 0xfd, 0x68, 0x1c, 0x84, 0xd7, 0x18,
	0xb8, 0xac, 0x72, 0xf6, 0x4b, 0xa8, 0x08, 0xcd, 0xc4, 0x5b, 0xfe, 0xed, 0xaa, 0xc2, 0x8d, 0xf2,
	0x6a, 0xfc, 0x10, 0x60, 0xfd, 0x3d, 0xa8, 0x0e, 0x07, 0x89, 0x11, 0xce, 0xda, 0x3c, 0x4e, 0xb6,
	0xc6, 0x6f, 0xa0, 0xb4, 0x0a, 0x14, 0x7d, 0x04, 0xe5, 0x79, 0x4c, 0xae, 0x82, 0xd7, 0x2e, 0x0d,
	0xbe, 0x26, 0xaa, 0xe5, 0x82, 0x84, 0x06, 0xc1, 0xd7, 0xfc, 0xe1, 0x6f, 0xa7, 0xab, 0x92, 0xca,
	0x8e, 0xf1, 0x37, 0x0d, 0x8e, 0x76, 0xbe, 0x8b, 0x5b, 0xbd, 0x0a, 0x62, 0xca, 0xdc, 0x57, 0xde,
	0x74, 0x21, 0xad, 0x66, 0x31, 0x08, 0xe8, 0x2b, 0x8e, 0x70, 0x66, 0x89, 0x38, 0xe7, 0x5e, 0xec,
	0xcd, 0x08, 0x23, 0xb1, 0x6a, 0xde, 0x55, 0x8e, 0xf6, 0x13, 0x90, 0xdb, 0x09, 0x17, 0xb3, 0xd4,
	0x1f, 0x89, 0xf8, 0xba, 0x70, 0x31, 0x4b, 0x1a, 0xfb, 0xc7, 0x50, 0x21, 0xdc, 0x29, 0x19, 0xbb,
	0xab, 0x41, 0xbc, 0x82, 0xcb, 0x0a, 0xe3, 0x63, 0x80, 0xf1, 0x47, 0x0d, 0xee, 0xec, 0x19, 0xc9,
	0x91, 0x09, 0x07, 0xeb, 0x41, 0x83, 0x3f, 0xeb, 0x1f, 0xdd, 0x38, 0xbe, 0x37, 0x92, 0x85, 0xfc,
	0x1d, 0x48, 0xf4, 0x4e, 0x9f, 0x40, 0x75, 0xe3, 0x84, 0x53, 0xf8, 0x25, 0x79, 0xa3, 0x58, 0xcd,
	0x97, 0x7c, 0xc8, 0x92, 0x39, 0x90, 0x99, 0x93, 0x1b, 0xe3, 0x9f, 0x1a, 0x1c, 0xaf, 0xbb, 0x4c,
	0x8b, 0x50, 0x3f, 0x0e, 0xe6, 0x2c, 0x8a, 0xdf, 0xff, 0x08, 0x99, 0x7d, 0x97, 0x2e, 0x6c, 0x3c,
	0x83, 0x7b, 0x3c, 0x80, 0x75, 0x28, 0xeb, 0xaa, 0xf9, 0xab, 0xd5, 0x4f, 0x30, 0x1f, 0x4d, 0x92,
	0x1c, 0x9f, 0xa6, 0x0d, 0x6f, 0xc6, 0x9e, 0xfc, 0x0e, 0x0b, 0x33, 0xe7, 0x7f, 0x58, 0xfd, 0x52,
	0x8b, 0x6f, 0xfd, 0x00, 0xee, 0x0d, 0x2f, 0xb0, 0x65, 0x0e, 0xf7, 0x35, 0x9f, 0x32, 0x1c, 0x74,
	0xcd, 0xce, 0xa5, 0x89, 0x79, 0xd7, 0xb9, 0x0b, 0x68, 0xd0, 0x6b, 0xf2, 0x46, 0x64, 0x39, 0x4f,
	0x6d, 0xc7, 0xb2, 0xb0, 0xed, 0x3c, 0xd5, 0x33, 0xe8, 0x04, 0x8e, 0x46, 0xce, 0xa5, 0xe9, 0x0c,
	0xad, 0x96, 0x3b, 0xe8, 0xb5, 0x87, 0x42, 0x3c, 0x8b, 0x3e, 0x81, 0x8f, 0xfa, 0xbd, 0xa1, 0xe5,
	0xf0, 0xd6, 0xd5, 0x79, 0xee, 0x5e, 0x98, 0xb8, 0xdb, 0x1e, 0x75, 0x5c, 0xb3, 0xdf, 0xef, 0xd8,
	0x4d, 0x73, 0x68, 0xf7, 0x1c, 0x3d, 0x77, 0xfe, 0x67, 0x0d, 0x2a, 0xe9, 0x44, 0xf2, 0x6e, 0xd8,
	0xef, 0x98, 0xc3, 0x76, 0x0f, 0x77, 0x6f, 0xf8, 0xa0, 0x4b, 0xdb, 0x69, 0xf5, 0x2e, 0x07, 0xba,
	0x86, 0x4a, 0x90, 0xef, 0xd8, 0xce, 0xe8, 0x99, 0x9e, 0xe1, 0xb8, 0xe9, 0xb4, 0x70, 0xcf, 0x6e,
	0xe9, 0x59, 0x74, 0x00, 0xd9, 0xde, 0xe0, 0x99, 0x9e, 0xe3, 0x0b, 0xbb, 0x37, 0xd0, 0xf3, 0x48,
	0x87, 0x8a, 0xe9, 0x3c, 0x77, 0x13, 0xcb, 0x7a, 0x01, 0x1d, 0x41, 0xd5, 0xec, 0x74, 0x56, 0xc8,
	0x40, 0x3f, 0x40, 0x00, 0x85, 0xe6, 0x05, 0xee, 0x75, 0x2d, 0xbd, 0x78, 0xde, 0x86, 0xc3, 0xad,
	0x72, 0x87, 0xce, 0xe0, 0xfb, 0xcd, 0x5e, 0xb7, 0x8f, 0xad, 0xc1, 0xc0, 0xee, 0x39, 0xfb, 0x3e,
	0xee, 0x00, 0xb2, 0xd8, 0xbc, 0xd4, 0x35, 0x54, 0x84, 0x1c, 0xb6, 0x9b, 0x96, 0x9e, 0x39, 0xff,
	0x1d, 0x1c, 0x6e, 0x5d, 0x35, 0xfa, 0x18, 0x1e, 0xa8, 0x84, 0x5b, 0xce, 0x10, 0x3f, 0xbf, 0xc1,
	0xd0, 0x08, 0x77, 0x74, 0x0d, 0xd5, 0x00, 0xac, 0x67, 0x56, 0x73, 0x34, 0x34, 0x7f, 0xdd, 0xb1,
	0xf4, 0x0c, 0xaa, 0x40, 0xd1, 0xee, 0xbb, 0xd8, 0x74, 0x9e, 0x5a, 0x7a, 0xf6, 0x45, 0x41, 0x74,
	0xa6, 0xc7, 0xff, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x0e, 0x80, 0x93, 0xf0, 0x5f, 0x11, 0x00, 0x00,
}
